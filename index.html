<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Volleyball Showdown</title>
    <!-- Use Tailwind CDN for the main document structure -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom CSS for the Game Canvas and Elements */
        @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@600;700&display=swap');

        body {
            background-color: #1a202c; /* Dark background */
            font-family: 'Chakra Petch', sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        #game-container {
            border: 8px solid #3c82f6; /* Blue border */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            border-radius: 20px;
            overflow: hidden;
            background-color: #0d1117;
            max-width: 90vw;
            width: 800px; /* Base width */
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #gameCanvas {
            background-color: #3b82f6; /* Court background */
            display: block;
            width: 100%;
            height: auto; /* Managed by JS to maintain aspect ratio */
            border-radius: 12px 12px 0 0;
        }

        .score-board {
            width: 100%;
            padding: 10px 20px;
            background-color: #1f2937;
            color: #f9f9f9;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.5rem;
            border-radius: 0 0 12px 12px;
            box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.3);
        }

        .controls-info {
            background-color: #1f2937;
            color: #d1d5db;
            padding: 10px;
            margin-top: 20px;
            border-radius: 8px;
            text-align: center;
            font-size: 0.8rem;
            max-width: 800px;
            width: 100%;
        }

        .key {
            display: inline-block;
            background-color: #4b5563;
            color: #ffffff;
            padding: 2px 6px;
            border-radius: 4px;
            margin: 0 2px;
            box-shadow: 0 2px 0 #1f2937;
        }
        
        #restart-button {
            transition: all 0.15s ease-in-out;
            transform: scale(1);
        }
        #restart-button:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(248, 113, 113, 0.4);
        }

        @media (max-width: 640px) {
            .score-board {
                font-size: 1.2rem;
            }
            .controls-info {
                font-size: 0.7rem;
            }
        }
    </style>
</head>
<body>

    <div id="game-container" class="transition-all duration-300">
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        <div class="score-board">
            <div id="score-p1" class="font-bold text-yellow-300">Player 1 (WAD): 0</div>
            
            <div class="flex flex-col items-center">
                <div id="status-message" class="text-center text-sm font-semibold text-white">Press SPACE to serve</div>
                <button id="restart-button" class="mt-1 px-3 py-1 bg-red-600 text-white rounded-lg shadow-md hover:bg-red-700 transition duration-150 hidden">RESTART GAME</button>
            </div>
            
            <div id="score-p2" class="font-bold text-red-400">Computer: 0</div>
        </div>
    </div>
    <div class="controls-info">
        <p class="mb-1">
            <span class="font-bold text-yellow-300">Player 1:</span> Move <span class="key">A</span> <span class="key">D</span>, Jump/Hit <span class="key">W</span>
        </p>
        <p>
            <span class="font-bold text-red-400">Computer:</span> **AI Controlled**
        </p>
        <p class="mt-2 text-xs text-gray-400">
            **Rule:** Max **3 hits** per side! Jump and hit while moving down to **SPIKE**!
        </p>
    </div>

    <script>
        // Game Constants
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 400;
        const COURT_COLOR = '#3b82f6';
        const LINE_COLOR = '#ffffff';
        const NET_COLOR = '#eeeeee';
        const GRAVITY = 0.5;
        const PLAYER_SPEED = 5;
        const JUMP_POWER = 12;
        const MAX_SCORE = 5;
        const MAX_TOUCHES = 3; // Max hits per side before crossing the net
        
        // AI Constants
        const AI_SPEED = 4.0; // Slightly slower than the player
        const AI_JUMP_THRESHOLD_X = 60; // Horizontal distance to trigger a jump
        const AI_SPIKE_Y = 150; // Y position for prioritizing a spike (higher is better)

        // Setup Canvas
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // DOM Elements
        const scoreP1El = document.getElementById('score-p1');
        const scoreP2El = document.getElementById('score-p2');
        const statusMessageEl = document.getElementById('status-message');
        const restartButtonEl = document.getElementById('restart-button');

        // Game State
        let gameRunning = true;
        let ballInPlay = false;
        let winningPlayer = null;
        let lastTouch = null; // 'p1' or 'p2'
        let serveReady = true;
        let p1Touches = 0; // Tracks consecutive hits by P1 side
        let p2Touches = 0; // Tracks consecutive hits by P2 side
        let lastPlayerHit = null; // Tracks the ID of the last player to hit

        // Game Objects
        const Court = {
            width: CANVAS_WIDTH,
            height: CANVAS_HEIGHT,
            netX: CANVAS_WIDTH / 2,
            netHeight: 150,
            floorY: CANVAS_HEIGHT - 20,
            netY: CANVAS_HEIGHT - 20 - 150, // Top of the net
            playerArea: {
                p1: { minX: 0, maxX: CANVAS_WIDTH / 2 - 20 },
                p2: { minX: CANVAS_WIDTH / 2 + 20, maxX: CANVAS_WIDTH }
            }
        };

        class Player {
            constructor(x, color, controls) {
                this.x = x;
                this.y = Court.floorY - 60;
                this.width = 40;
                this.height = 60;
                this.color = color;
                this.score = 0;
                this.dx = 0; // Horizontal velocity
                this.dy = 0; // Vertical velocity (jump)
                this.isJumping = false;
                this.isServing = false;
                this.controls = controls; // { up, left, right, side }
                this.isAI = (controls.side === 'p2'); // Player 2 is the AI
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                // Body (Rounded Rectangle)
                ctx.roundRect(this.x - this.width / 2, this.y, this.width, this.height, 5);
                ctx.fill();

                // Eyes (Small circles for simple face)
                ctx.fillStyle = '#1f2937';
                ctx.beginPath();
                ctx.arc(this.x - 10, this.y + 15, 3, 0, Math.PI * 2);
                ctx.arc(this.x + 10, this.y + 15, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            update() {
                // Apply Gravity
                if (this.y < Court.floorY - this.height) {
                    this.dy += GRAVITY;
                    this.isJumping = true;
                } else {
                    this.y = Court.floorY - this.height;
                    this.dy = 0;
                    this.isJumping = false;
                }

                this.y += this.dy;

                // Horizontal movement
                this.x += this.dx;

                // Restrict movement to own side
                const side = this.controls.side;
                if (this.x < Court.playerArea[side].minX + this.width / 2) {
                    this.x = Court.playerArea[side].minX + this.width / 2;
                }
                if (this.x > Court.playerArea[side].maxX - this.width / 2) {
                    this.x = Court.playerArea[side].maxX - this.width / 2;
                }
            }

            jump() {
                if (!this.isJumping) {
                    this.dy = -JUMP_POWER;
                    this.isJumping = true;
                }
            }
        }

        class Ball {
            constructor(x, y, radius) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.dx = 0;
                this.dy = 0;
                this.color = '#facc15';
                this.bounceFactor = 0.8;
                this.maxSpeed = 15;
            }

            draw() {
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Simple lines to make it look like a volleyball
                ctx.strokeStyle = '#fef3c7';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(this.x - this.radius, this.y);
                ctx.lineTo(this.x + this.radius, this.y);
                ctx.moveTo(this.x, this.y - this.radius);
                ctx.lineTo(this.x, this.y + this.radius);
                ctx.stroke();
            }

            update() {
                if (!ballInPlay) return;

                // Apply gravity to vertical velocity
                this.dy += GRAVITY;

                // Update position
                this.x += this.dx;
                this.y += this.dy;

                // Cap speed
                this.dx = Math.min(Math.max(this.dx, -this.maxSpeed), this.maxSpeed);
                this.dy = Math.min(Math.max(this.dy, -this.maxSpeed), this.maxSpeed);

                // Wall collisions (Left/Right)
                if (this.x - this.radius < 0 || this.x + this.radius > Court.width) {
                    this.dx *= -1;
                    this.x = Math.max(this.radius, Math.min(this.x, Court.width - this.radius));
                }

                // Ceiling collision
                if (this.y - this.radius < 0) {
                    this.dy *= -this.bounceFactor;
                    this.y = this.radius;
                }

                // Floor collision (Scoring Logic)
                if (this.y + this.radius > Court.floorY) {
                    this.y = Court.floorY - this.radius;
                    this.dy = 0; // Stop vertical movement
                    this.handleScore();
                }

                // Net collision
                this.handleNetCollision();
            }

            handleNetCollision() {
                const netWidth = 10;
                const netLeft = Court.netX - netWidth / 2;
                const netRight = Court.netX + netWidth / 2;
                const netTop = Court.netY;

                // Check for collision with the net structure
                if (
                    this.x + this.radius > netLeft && this.x - this.radius < netRight &&
                    this.y + this.radius > netTop
                ) {
                    // Ball is hitting the net

                    // 1. Horizontal Bounce (if hitting the side of the net)
                    if (this.x < netLeft && this.dx > 0) { // Hitting left side of net, moving right
                        this.x = netLeft - this.radius;
                        this.dx *= -0.7; // Reduced horizontal bounce
                    } else if (this.x > netRight && this.dx < 0) { // Hitting right side of net, moving left
                        this.x = netRight + this.radius;
                        this.dx *= -0.7;
                    }

                    // 2. Vertical Bounce (if hitting the top edge of the net)
                    if (this.y < netTop && this.dy > 0 && Math.abs(this.x - Court.netX) < netWidth / 2) {
                         this.y = netTop - this.radius;
                         this.dy *= -0.7; // Reduced vertical bounce
                    }

                    // 3. If below the net top, treat it as a dead ball or a strong bounce
                    if (this.y + this.radius > netTop) {
                        // The ball is hitting the main net body
                        // If the ball's center is on one side, force it back to that side
                        if (this.x < Court.netX) { // On left side
                            if (this.dx > 0) this.dx *= -1; // Push it back left
                        } else { // On right side
                            if (this.dx < 0) this.dx *= -1; // Push it back right
                        }
                        this.dx *= 0.5; // Slow down
                    }
                }
            }

            handleScore() {
                ballInPlay = false;
                serveReady = true;
                p1Touches = 0; // Reset touches on score
                p2Touches = 0; // Reset touches on score
                lastPlayerHit = null; // Reset last hit

                let scoringPlayer = null;
                const hitFloorX = this.x;

                // Check which side the ball landed on
                if (hitFloorX < Court.netX) {
                    // Landed on Player 1's side (Player 2 scores)
                    scoringPlayer = p2;
                    statusMessageEl.textContent = "Point for Computer (P1 side floor)!";
                } else {
                    // Landed on Player 2's side (Player 1 scores)
                    scoringPlayer = p1;
                    statusMessageEl.textContent = "Point for Player 1 (Computer side floor)!";
                }

                if (scoringPlayer) {
                    scoringPlayer.score++;
                    this.checkWinCondition();
                }
            }

            checkWinCondition() {
                if (p1.score >= MAX_SCORE) {
                    winningPlayer = 'Player 1';
                    gameRunning = false;
                } else if (p2.score >= MAX_SCORE) {
                    winningPlayer = 'Computer';
                    gameRunning = false;
                }

                if (!gameRunning) {
                    statusMessageEl.textContent = `${winningPlayer} Wins! Game Over.`;
                    restartButtonEl.classList.remove('hidden');
                }
            }
        }

        // Initialize Players and Ball
        const p1 = new Player(CANVAS_WIDTH / 4, '#fde047', { up: 'w', left: 'a', right: 'd', side: 'p1' });
        // NOTE: p2 is now AI controlled, so controls object is irrelevant but kept for structure
        const p2 = new Player(CANVAS_WIDTH * 3 / 4, '#f87171', { up: 'ArrowUp', left: 'ArrowLeft', right: 'ArrowRight', side: 'p2' }); 
        const ball = new Ball(p1.x, p1.y - 40, 15);

        // Input Tracking
        const keysPressed = {};

        document.addEventListener('keydown', (e) => {
            keysPressed[e.key] = true;

            // Serve action
            if (e.key === ' ' && !ballInPlay && serveReady) {
                ballInPlay = true;
                serveReady = false;
                
                // Determine server: P1 serves on even points, P2/AI on odd
                const server = (p1.score + p2.score) % 2 === 0 ? p1 : p2;

                if (server.isAI) {
                    // AI serve logic (will be handled by updateAI on next frame)
                    statusMessageEl.textContent = "Computer Serving...";
                } else {
                    // Human serve logic
                    const initialDx = (ball.x < Court.netX) ? 5 : -5;
                    ball.dx = initialDx * (1 + Math.random() * 0.5); 
                    ball.dy = -10; // Initial upward velocity
                    statusMessageEl.textContent = "Game In Progress!";
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keysPressed[e.key] = false;
        });

        function handleInput() {
            if (!gameRunning) return;

            // Player 1 (Human) controls
            p1.dx = 0;
            if (keysPressed[p1.controls.left]) p1.dx = -PLAYER_SPEED;
            if (keysPressed[p1.controls.right]) p1.dx = PLAYER_SPEED;
            if (keysPressed[p1.controls.up]) p1.jump();

            // Player 2 (AI) controls are handled by updateAI, so no keyboard input here.
        }

        function updateAI(aiPlayer) {
            if (!gameRunning) return;

            // --- Serving Logic ---
            if (!ballInPlay && serveReady) {
                if (aiPlayer.isServing) {
                    // AI is server, initiate serve automatically
                    ballInPlay = true;
                    serveReady = false;
                    aiPlayer.isServing = false;
                    
                    // Simple AI serve: aim diagonally towards P1's side
                    const initialDx = -6; // Towards P1's side
                    ball.dx = initialDx + (Math.random() - 0.5) * 2; 
                    ball.dy = -10 - Math.random() * 3; 
                    statusMessageEl.textContent = "Game In Progress!";
                }
                return; // Wait for human to press SPACE
            }

            // --- Movement Logic ---
            const targetX = ball.x;
            const aiCenter = aiPlayer.x;
            const speed = AI_SPEED;

            aiPlayer.dx = 0;

            // Only move if the ball is on the AI's side or approaching the net
            const shouldMove = ballInPlay && (ball.x > Court.netX - 50); 

            if (shouldMove) {
                if (targetX > aiCenter + 5) {
                    aiPlayer.dx = speed;
                } else if (targetX < aiCenter - 5) {
                    aiPlayer.dx = -speed;
                }
            } else {
                // Return to a neutral waiting position 
                const neutralX = Court.width * 3 / 4;
                if (Math.abs(neutralX - aiCenter) > 5) {
                    aiPlayer.dx = (neutralX > aiCenter) ? speed : -speed;
                }
            }
            
            // --- Jumping/Hitting Logic ---
            const horizontalDistance = Math.abs(ball.x - aiPlayer.x);
            const verticalReach = aiPlayer.y - ball.y; // Positive when ball is above AI's head

            // Conditions for jump:
            const ballInAIArea = ball.x > Court.netX;

            if (ballInPlay && ballInAIArea && !aiPlayer.isJumping) {
                const canReachHorizontally = horizontalDistance < AI_JUMP_THRESHOLD_X;

                if (canReachHorizontally) {
                    // Check for a spike opportunity (ball is high and descending aggressively)
                    const isSpikeOpportunity = ball.dy > 1.5 && ball.y < Court.netY + ball.radius; 

                    if (isSpikeOpportunity && Math.random() < 0.8) { // 80% chance to spike if possible
                        aiPlayer.jump();
                    } 
                    // Otherwise, jump if the ball is within a good vertical window
                    else if (verticalReach > 0 && verticalReach < aiPlayer.height * 2) { 
                        aiPlayer.jump();
                    }
                }
            }
        }

        function handleFoul(foulingPlayerId) {
            ballInPlay = false;
            serveReady = true;

            let scoringPlayer = (foulingPlayerId === 'p1') ? p2 : p1;
            const foulText = `FOUL! ${foulingPlayerId === 'p1' ? 'Player 1' : 'Computer'} exceeded ${MAX_TOUCHES} touches.`;
            const scoreText = `Point for ${scoringPlayer === p1 ? 'Player 1' : 'Computer'}!`;

            scoringPlayer.score++;
            statusMessageEl.textContent = `${foulText} ${scoreText}`;

            p1Touches = 0;
            p2Touches = 0;
            lastPlayerHit = null;

            ball.checkWinCondition();
        }

        function checkPlayerBallCollision(player, ball) {
            // Simple AABB vs Circle check
            const closestX = Math.max(player.x - player.width / 2, Math.min(ball.x, player.x + player.width / 2));
            const closestY = Math.max(player.y, Math.min(ball.y, player.y + player.height));

            const distanceX = ball.x - closestX;
            const distanceY = ball.y - closestY;
            const distanceSq = (distanceX * distanceX) + (distanceY * distanceY);

            if (distanceSq < (ball.radius * ball.radius)) {
                // Collision detected!

                // 1. Calculate the new velocity magnitude and collision vector
                const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                const impactForce = 1.0; 

                let normalX = ball.x - closestX;
                let normalY = ball.y - closestY;
                const normalLength = Math.sqrt(normalX * normalX + normalY * normalY);
                normalX /= normalLength;
                normalY /= normalLength;

                let newDx = normalX * speed * impactForce + player.dx * 0.5;
                let newDy = normalY * speed * impactForce + player.dy * 0.5;

                // Push ball out of player's bounds to prevent sticky behavior
                const overlap = ball.radius - normalLength;
                ball.x += normalX * overlap * 1.5;
                ball.y += normalY * overlap * 1.5;


                // === GAMEPLAY LOGIC: TOUCH COUNT & SPIKE BOOST ===
                
                const playerId = (player === p1) ? 'p1' : 'p2';
                const opponentId = (player === p1) ? 'p2' : 'p1';

                // Check if the ball just crossed the net (touching player is the first touch on this side)
                if (lastPlayerHit === opponentId) {
                    p1Touches = (player === p1) ? 1 : 0;
                    p2Touches = (player === p2) ? 1 : 0;
                } else {
                    // Same side consecutive touch
                    if (player === p1) p1Touches++;
                    else p2Touches++;
                }
                
                // Check for Triple Touch Foul
                if ((player === p1 && p1Touches > MAX_TOUCHES) || (player === p2 && p2Touches > MAX_TOUCHES)) {
                    handleFoul(playerId);
                    return; // Stop processing collision if foul occurred
                }

                // Apply Spike/Hit Boost (Stronger hit if jumping and descending: 'spike')
                let powerBoost = 1.0;
                if (player.isJumping && player.dy > 0 && ball.y < Court.netY + ball.radius) {
                    // Player is jumping, moving downwards, and ball is high (spike!)
                    powerBoost = 1.5;
                    newDx *= 1.2; // Add more horizontal speed to the spike
                    newDy *= 1.2;
                    const hitterName = playerId === 'p1' ? 'Player 1' : 'Computer';
                    statusMessageEl.textContent = `${hitterName} SPIKE!`;
                } else if (ballInPlay) {
                    const hitterName = playerId === 'p1' ? 'Player 1' : 'Computer';
                    statusMessageEl.textContent = `Hit ${player === p1 ? p1Touches : p2Touches} for ${hitterName}!`;
                }

                // Apply new velocity
                ball.dx = newDx * powerBoost;
                ball.dy = newDy * powerBoost;

                // Ensure a minimum upward velocity for better gameplay feel
                if (ball.dy > -5) ball.dy = -5;

                // Enforce max speed after boost
                ball.dx = Math.min(Math.max(ball.dx, -ball.maxSpeed), ball.maxSpeed);
                ball.dy = Math.min(Math.max(ball.dy, -ball.maxSpeed), ball.maxSpeed);

                // Update last touch for physics/net collision logic
                lastPlayerHit = playerId;
            }
        }
        
        // --- Game Utility Functions ---

        function resetGame() {
            p1.score = 0;
            p2.score = 0;
            p1.x = CANVAS_WIDTH / 4;
            p2.x = CANVAS_WIDTH * 3 / 4;
            
            // Set ball to starting server (P1 for start)
            ball.x = p1.x;
            ball.y = p1.y - 40;
            ball.dx = 0;
            ball.dy = 0;

            gameRunning = true;
            ballInPlay = false;
            serveReady = true;
            p1Touches = 0;
            p2Touches = 0;
            lastPlayerHit = null;
            winningPlayer = null;
            
            // Set first server
            const server = (p1.score + p2.score) % 2 === 0 ? p1 : p2;
            server.isServing = true;
            const serverName = server === p1 ? 'Player 1' : 'Computer';
            
            statusMessageEl.textContent = `${serverName} to serve. Press SPACE.`;
            restartButtonEl.classList.add('hidden');
        }
        
        // Add listener for the new restart button
        restartButtonEl.addEventListener('click', resetGame);


        // --- Drawing Functions ---

        function drawCourt() {
            // Draw Court Floor
            ctx.fillStyle = COURT_COLOR;
            ctx.fillRect(0, Court.floorY, Court.width, Court.height - Court.floorY);

            // Draw Court Line (Floor)
            ctx.strokeStyle = LINE_COLOR;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(0, Court.floorY);
            ctx.lineTo(Court.width, Court.floorY);
            ctx.stroke();

            // Draw Net
            ctx.fillStyle = NET_COLOR;
            const netWidth = 10;
            const netX = Court.netX - netWidth / 2;
            const netHeight = Court.netHeight;
            const netY = Court.floorY - netHeight;

            // Net posts
            ctx.fillRect(netX, netY, netWidth, netHeight);

            // Net mesh (simplified)
            ctx.strokeStyle = '#aaaaaa';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                ctx.moveTo(netX, netY + i * (netHeight / 4));
                ctx.lineTo(netX + netWidth, netY + i * (netHeight / 4));
            }
            ctx.stroke();

            // Center dividing line (under the net)
            ctx.strokeStyle = LINE_COLOR;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(Court.netX, netY);
            ctx.lineTo(Court.netX, Court.floorY);
            ctx.stroke();
        }

        function draw() {
            // Clear Canvas
            ctx.clearRect(0, 0, Court.width, Court.height);

            // Draw Court
            drawCourt();

            // Draw Players
            p1.draw();
            p2.draw();

            // Draw Ball
            ball.draw();

            // Update Scoreboard
            scoreP1El.textContent = `Player 1 (WAD): ${p1.score}`;
            scoreP2El.textContent = `Computer: ${p2.score}`;
        }

        // --- Game Loop ---

        function update() {
            if (gameRunning) {
                // 1. Handle Input (Human Player 1)
                handleInput();

                // 2. Handle AI (Computer Player 2)
                updateAI(p2);

                // 3. Update Game Objects
                p1.update();
                p2.update();

                // If ball is not in play, keep it above the server
                if (!ballInPlay) {
                    const server = (p1.score + p2.score) % 2 === 0 ? p1 : p2; 
                    
                    ball.x = server.x; // Set ball above the server
                    ball.y = server.y - 40;
                    ball.dx = 0;
                    ball.dy = 0;
                    
                    // Set AI serving state
                    if (server.isAI && serveReady) {
                        server.isServing = true;
                    }

                    if (serveReady && !server.isAI) {
                        statusMessageEl.textContent = `Player 1 to serve. Press SPACE.`;
                    }
                } else {
                    ball.update();

                    // 4. Collision Checks
                    checkPlayerBallCollision(p1, ball);
                    checkPlayerBallCollision(p2, ball);
                }
            }

            // 5. Draw
            draw();

            // Request next frame
            requestAnimationFrame(update);
        }

        // Start the game loop on window load
        window.onload = function () {
            // Set initial server
            p1.isServing = true;
            requestAnimationFrame(update);
        }

    </script>
</body>
</html>
