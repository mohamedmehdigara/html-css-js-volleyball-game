<!DOCTYPE html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Volleyball Showdown</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* Custom CSS for the Game Canvas and Elements */
        @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@600;700&display=swap');

        body {
            background-color: #1a202c; /* Dark background */
            font-family: 'Chakra Petch', sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        #game-container {
            border: 8px solid #3c82f6; /* Blue border */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            border-radius: 20px;
            overflow: hidden;
            background-color: #0d1117;
            max-width: 90vw;
            width: 800px; /* Base width */
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative; /* Needed for screen shake and shadow */
            transition: all 0.1s ease;
        }

        #gameCanvas {
            background-color: #3b82f6; /* Court background */
            display: block;
            width: 100%;
            height: auto; /* Managed by JS to maintain aspect ratio */
            border-radius: 12px 12px 0 0;
        }

        .score-bar-container {
            width: 100%;
            padding: 10px 20px;
            background-color: #1f2937;
            color: #f9f9f9;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.5rem;
            border-radius: 0 0 12px 12px;
            box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.3);
        }

        .controls-info {
            background-color: #1f2937;
            color: #d1d5db;
            padding: 10px;
            margin-top: 20px;
            border-radius: 8px;
            text-align: center;
            font-size: 0.8rem;
            max-width: 800px;
            width: 100%;
        }

        .key {
            display: inline-block;
            background-color: #4b5563;
            color: #ffffff;
            padding: 2px 6px;
            border-radius: 4px;
            margin: 0 2px;
            box-shadow: 0 2px 0 #1f2937;
        }
        
        #restart-button, #mute-button {
            transition: all 0.15s ease-in-out;
            transform: scale(1);
        }
        #restart-button:hover, #mute-button:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(248, 113, 113, 0.4);
        }
        
        /* Custom styles for the mute button icon (simple speaker) */
        #mute-button svg {
            width: 20px;
            height: 20px;
        }

        /* ‚≠ê NEW FEATURE: Game Pause Overlay Style */
        #pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 3rem;
            font-weight: bold;
            z-index: 10;
        }
        /* ‚≠ê NEW FEATURE: Ball Shadow Style */
        .ball-shadow {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.1s;
            pointer-events: none;
            z-index: 1; /* Below the canvas */
        }
        /* ‚≠ê NEW FEATURE: Wind Indicator Style */
        #wind-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            color: white;
            font-size: 0.8rem;
            line-height: 20px;
            text-align: center;
            z-index: 5;
            padding: 0 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
        }


        @media (max-width: 640px) {
            .score-bar-container {
                font-size: 1.2rem;
                padding: 8px 10px;
            }
            .controls-info {
                font-size: 0.7rem;
            }
        }
    </style>
</head>
<body>

    <div id="game-container" class="transition-all duration-300">
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        
        <div id="ball-shadow" class="ball-shadow"></div> <div id="pause-overlay">
            PAUSED
            <span class="text-lg mt-4 font-normal">Press P to resume</span>
        </div>
        
        <div id="wind-indicator" class="hidden">
            <span id="wind-icon">üå¨Ô∏è</span>
            <span id="wind-strength">Calm</span>
        </div>

        <div class="score-bar-container">
            <div id="score-p1" class="font-bold text-yellow-300">P1 (Arrows): 0</div>
            
            <div class="flex flex-col items-center flex-grow mx-4">
                <div id="game-timer" class="text-2xl font-extrabold text-white mb-1">05:00</div>
                <div id="status-message" class="text-center text-sm font-semibold text-white">Press SPACE to serve</div>
                <div class="flex mt-1 space-x-2">
                    <button id="restart-button" class="px-3 py-1 bg-red-600 text-white rounded-lg shadow-md hover:bg-red-700 transition duration-150 hidden">RESTART GAME</button>
                    <button id="mute-button" class="px-2 py-1 bg-gray-600 text-white rounded-lg shadow-md hover:bg-gray-500 transition duration-150">
                        <svg id="mute-icon-unmuted" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M18.784 4.25c.346.126.65.313.916.556C20.407 6.273 21 8.243 21 10.25a11.16 11.16 0 0 1-1.385 5.564c-.266.243-.57.43-.916.556a8.88 8.88 0 0 0 0-6.17c-.346-.126-.65-.313-.916-.556A10.165 10.165 0 0 0 17 10.25c0-.655.088-1.294.246-1.9.157-.606.39-1.18.683-1.706a7.882 7.882 0 0 1-.683-1.706c-.158-.606-.39-1.18-.683-1.706-.293-.526-.626-.976-.997-1.35C16.52 3.868 17 3.25 17 2.5a.75.75 0 0 0-.75-.75h-2.5a.75.75 0 0 0-.75.75c0 .75.52 1.368 1.184 1.634.346.126.65.313.916.556a8.88 8.88 0 0 0 0 6.17ZM17 10.25a.75.75 0 0 0 1.5 0v-.5a.75.75 0 0 0-1.5 0v.5Z" />
                            <path fill-rule="evenodd" d="M12.28 1.28a.75.75 0 0 0-1.06 0l-7.5 7.5A.75.75 0 0 0 3 9.39V15a3 3 0 0 0 3 3h2.15l.48.567a.75.75 0 0 0 1.05.006l4.68-5.748a.75.75 0 0 0 .006-1.05Z" clip-rule="evenodd" />
                        </svg>
                        <svg id="mute-icon-muted" class="hidden" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M13.28 1.28a.75.75 0 0 0-1.06 0l-7.5 7.5A.75.75 0 0 0 3 9.39V15a3 3 0 0 0 3 3h2.15l.48.567a.75.75 0 0 0 1.05.006l4.68-5.748a.75.75 0 0 0 .006-1.05L13.28 1.28Z" />
                            <path fill-rule="evenodd" d="M19.057 4.293a.75.75 0 0 0-1.06-1.06l-1.97 1.97L15.057 3.23a.75.75 0 0 0-1.06 1.06l1.97 1.97-1.97 1.97a.75.75 0 1 0 1.06 1.06l1.97-1.97 1.97 1.97a.75.75 0 1 0 1.06-1.06l-1.97-1.97 1.97-1.97a.75.75 0 0 0 0-1.06Z" clip-rule="evenodd" />
                        </svg>
                    </button>
                </div>
            </div>
            
            <div id="score-p2" class="font-bold text-red-400">Computer: 0</div>
        </div>
    </div>
    <div class="controls-info">
        <p class="mb-1">
            <span class="font-bold text-yellow-300">Player 1:</span> Move <span class="key">‚Üê</span> <span class="key">‚Üí</span>, Jump/Hit <span class="key">‚Üë</span>, Air Dash <span class="key">E</span>, Pause <span class="key">P</span>
        </p>
        <p>
            <span class="font-bold text-red-400">Computer:</span> **AI Controlled** (Uses Dash Strategically)
        </p>
        <p class="mt-2 text-sm text-yellow-300">
            **New:** Look for the **Super Jump Power-Up** (Blue Star) to jump higher!
        </p>
        <div class="mt-3 text-sm flex items-center justify-center">
            <label for="difficulty-slider" class="mr-3 text-white font-semibold">AI Difficulty:</label>
            <input type="range" id="difficulty-slider" min="1" max="10" value="5" class="w-1/2 h-2 appearance-none bg-gray-600 rounded-full focus:outline-none">
            <span id="difficulty-label" class="ml-3 w-20 text-yellow-300 font-bold text-left">Medium (5)</span>
        </div>
        <p class="mt-2 text-xs text-gray-400">
            Features: **Game Timer (5 min)**, **Super Jump Power-Up**, **Mid-Air Dash**, **Ball Spin (Magnus Effect)**, **Dynamic Wind**, **Ball Shadow**, **AI Difficulty**, **Spike Flash**, **Pause Screen**.
        </p>
    </div>

    <script>
        // Game Constants
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 400;
        const COURT_COLOR = '#3b82f6';
        const LINE_COLOR = '#ffffff';
        const NET_COLOR = '#eeeeee';
        const GRAVITY = 0.5;
        const BASE_PLAYER_SPEED = 5;
        const BASE_JUMP_POWER = 12;
        const MAX_SCORE = 5;
        const MAX_TOUCHES = 3;
        
        // Timer Constant (5 minutes)
        const GAME_TIMER_SECONDS = 5 * 60; 

        // Boost Constants (used for Spikes and Power-Ups)
        const BOOST_TIME = 360; // 6 seconds at ~60 FPS
        const BOOST_SPEED_FACTOR = 1.3; 
        const BOOST_JUMP_FACTOR = 1.6; // Higher factor for the power-up effect

        // Power-Up Constants
        const POWERUP_RESPAWN_MIN = 60 * 5; // 5 seconds
        const POWERUP_RESPAWN_MAX = 60 * 15; // 15 seconds
        const POWERUP_COLOR = '#34d399'; // Green/Teal

        // Stamina Constants
        const MAX_STAMINA = 100;
        const JUMP_COST = 30;
        const REGEN_RATE_GROUNDED = 2;
        const REGEN_RATE_AIR = 0.5;
        
        // Air Dash Constants
        const DASH_COST = 40;
        const DASH_COOLDOWN_FRAMES = 60; // 1 second cooldown
        const DASH_FORCE_H = 15;
        const DASH_FORCE_V = -5; 
        
        // Wind Constants
        const WIND_DURATION_MIN = 300; 
        const WIND_DURATION_MAX = 420; 
        const MAX_WIND_FORCE = 0.2; 
        
        // Ball Spin Constants (Magnus Effect Approximation)
        const SPIN_AIR_DRAG = 0.005; 
        const MAGNUS_FACTOR = 0.008; 

        // Screen Shake State
        let screenShakeDuration = 0;
        let screenShakeIntensity = 0;
        let canvasContainerEl = document.getElementById('game-container');
        
        // AI Settings (Dynamic Difficulty)
        const AI_SETTINGS = {
            level: 5,
            baseSpeed: 4.0, 
            baseJumpRange: 60, 
            
            getSpeed() {
                // ‚≠ê NEW FEATURE: Make AI speed slightly dynamic based on difficulty
                return this.baseSpeed * (1 + (this.level - 5) * 0.1); 
            },
            getJumpRange() {
                // ‚≠ê NEW FEATURE: Make AI jump reaction time dynamic based on difficulty
                return this.baseJumpRange / (1 + (this.level - 5) * 0.08); 
            },
            // ‚≠ê NEW FEATURE: New AI property for dash strategy
            getDashChance() {
                return (this.level - 1) * 0.02; // 0% at level 1, up to 18% at level 10
            }
        };

        // Setup Canvas
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // DOM Elements
        const scoreP1El = document.getElementById('score-p1');
        const scoreP2El = document.getElementById('score-p2');
        const statusMessageEl = document.getElementById('status-message');
        const restartButtonEl = document.getElementById('restart-button');
        const muteButtonEl = document.getElementById('mute-button');
        const muteIconUnmutedEl = document.getElementById('mute-icon-unmuted');
        const muteIconMutedEl = document.getElementById('mute-icon-muted');
        const gameTimerEl = document.getElementById('game-timer');
        const pauseOverlayEl = document.getElementById('pause-overlay'); // ‚≠ê NEW FEATURE: Pause Overlay DOM
        const windIndicatorEl = document.getElementById('wind-indicator'); // ‚≠ê NEW FEATURE: Wind Indicator DOM
        const windStrengthEl = document.getElementById('wind-strength'); // ‚≠ê NEW FEATURE: Wind Indicator DOM
        const windIconEl = document.getElementById('wind-icon'); // ‚≠ê NEW FEATURE: Wind Indicator DOM
        
        // DOM Elements for Difficulty Control
        const difficultySliderEl = document.getElementById('difficulty-slider');
        const difficultyLabelEl = document.getElementById('difficulty-label');
        // ‚≠ê FIX: Added missing Ball Shadow DOM element reference
        const ballShadowEl = document.getElementById('ball-shadow'); 


        // Audio Initialization
        let hitSynth;
        let scoreSynth;
        let spikeSynth;
        let dashSynth;
        let powerupSynth;
        // ‚≠ê NEW FEATURE: New sound for Game Over
        let gameEndSynth; 
        let audioReady = false;
        let isMuted = false;

        function initAudio() {
            if (audioReady) return;
            
            try {
                // Initialize Tone.js
                hitSynth = new Tone.PolySynth(Tone.AMSynth, { volume: -10 }).toDestination();
                scoreSynth = new Tone.MembraneSynth({
                    pitchDecay: 0.05,
                    octaves: 10,
                    oscillator: { type: "square" },
                    envelope: { attack: 0.001, decay: 0.4, sustain: 0.01 }
                }).toDestination();
                
                spikeSynth = new Tone.NoiseSynth({
                    noise: { type: 'white' },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 },
                    volume: -5
                }).toDestination();

                dashSynth = new Tone.NoiseSynth({
                    noise: { type: 'pink' },
                    envelope: { attack: 0.01, decay: 0.05, sustain: 0, release: 0.05 },
                    volume: -8
                }).toDestination();
                
                powerupSynth = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.05, decay: 0.1, sustain: 0.2, release: 0.1 },
                    volume: -5
                }).toDestination();
                
                // ‚≠ê NEW FEATURE: Game End Sound
                gameEndSynth = new Tone.Synth({
                    oscillator: { type: "sawtooth" },
                    envelope: { attack: 0.05, decay: 0.5, sustain: 0, release: 1 },
                    volume: -3
                }).toDestination();
                
                // Set up a simple click-to-start mechanism (required for web audio)
                document.documentElement.addEventListener('click', () => {
                    if (Tone.context.state !== 'running') {
                        Tone.start();
                    }
                }, { once: true });
                
                audioReady = true;
            } catch (error) {
                console.error("Tone.js initialization failed:", error);
            }
        }
        
        function toggleMute() {
            isMuted = !isMuted;
            Tone.Master.mute = isMuted;

            if (isMuted) {
                muteButtonEl.classList.replace('bg-gray-600', 'bg-red-700');
                muteIconUnmutedEl.classList.add('hidden');
                muteIconMutedEl.classList.remove('hidden');
            } else {
                muteButtonEl.classList.replace('bg-red-700', 'bg-gray-600');
                muteIconUnmutedEl.classList.remove('hidden');
                muteIconMutedEl.classList.add('hidden');
            }
        }
        
        // Difficulty Slider Event Listener
        difficultySliderEl.addEventListener('input', (e) => {
            const newLevel = parseInt(e.target.value);
            AI_SETTINGS.level = newLevel;
            
            let labelText = '';
            let labelColor = 'text-yellow-300';
            if (newLevel <= 3) { labelText = 'Easy'; labelColor = 'text-green-400'; }
            else if (newLevel <= 7) { labelText = 'Medium'; labelColor = 'text-yellow-300'; }
            else { labelText = 'Hard'; labelColor = 'text-red-500'; }
            
            difficultyLabelEl.textContent = `${labelText} (${newLevel})`;
            difficultyLabelEl.className = `ml-3 w-20 font-bold text-left ${labelColor}`;
        });

        // Game State
        let gameRunning = true;
        let ballInPlay = false;
        let winningPlayer = null;
        let serveReady = true;
        let p1Touches = 0; 
        let p2Touches = 0; 
        let lastPlayerHit = null; 
        let isPaused = false; 
        let gameTimeRemaining = GAME_TIMER_SECONDS;
        // ‚≠ê NEW FEATURE: Track serve side
        let lastServeSide = 'p1'; 

        // Wind State
        let windForce = 0; 
        let windTimer = 0; 
        // ‚≠ê NEW FEATURE: Smoother Wind Transition
        let windTargetForce = 0;
        let windTransitionRate = 0.005;
        
        // Spike Visual State
        let spikeFlashTimer = 0; 

        // Power-up State
        let powerUp = null;
        let powerUpRespawnTimer = 0;

        // ‚≠ê NEW FEATURE: Score Limit Mode vs Time Limit Mode
        let isScoreLimitMode = true; // Initially true
        // If MAX_SCORE is reached, win. If timer runs out, win by score difference.

        // Game Objects
        const Court = {
            width: CANVAS_WIDTH,
            height: CANVAS_HEIGHT,
            netX: CANVAS_WIDTH / 2,
            netHeight: 150,
            floorY: CANVAS_HEIGHT - 20,
            netY: CANVAS_HEIGHT - 20 - 150, // Top of the net
            playerArea: {
                p1: { minX: 0, maxX: CANVAS_WIDTH / 2 - 20 },
                p2: { minX: CANVAS_WIDTH / 2 + 20, maxX: CANVAS_WIDTH }
            }
        };

        class Player {
            constructor(x, color, controls) {
                this.initialX = x; // ‚≠ê NEW FEATURE: Initial position for reset
                this.initialY = Court.floorY - 60; // ‚≠ê NEW FEATURE: Initial position for reset
                this.x = x;
                this.y = Court.floorY - 60;
                this.width = 40;
                this.height = 60;
                this.color = color;
                this.score = 0;
                this.dx = 0; 
                this.dy = 0; 
                this.isJumping = false;
                this.isServing = false;
                this.controls = controls; 
                this.isAI = (controls.side === 'p2'); 
                
                // Boost state: 0=none, 1=Spike Boost, 2=Power-up Boost
                this.boostType = 0; 
                this.boostTimer = 0;
                
                // Stamina properties
                this.stamina = MAX_STAMINA;
                this.maxStamina = MAX_STAMINA;
                
                // Dash properties
                this.dashCooldown = 0;
                this.isDashing = false;
            }

            // ‚≠ê NEW FEATURE: Reset method for cleaner score resets
            resetPosition() {
                this.x = this.initialX;
                this.y = this.initialY;
                this.dx = 0;
                this.dy = 0;
                this.isJumping = false;
                this.isServing = false;
                this.boostType = 0;
                this.boostTimer = 0;
                this.stamina = this.maxStamina;
                this.dashCooldown = 0;
            }


            drawStaminaBar(ctx) {
                // ... (Existing implementation for Stamina Bar)
                const barWidth = this.width * 1.5;
                const barHeight = 5;
                const barX = this.x - barWidth / 2;
                const barY = this.y - 15; 

                // Background (Empty)
                ctx.fillStyle = '#4b5563';
                ctx.fillRect(barX, barY, barWidth, barHeight);

                // Cooldown Overlay (if dashing)
                if (this.dashCooldown > 0) {
                    const cdRatio = this.dashCooldown / DASH_COOLDOWN_FRAMES;
                    ctx.fillStyle = `rgba(249, 115, 22, ${cdRatio * 0.7})`; 
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                }

                // Foreground (Stamina)
                const currentWidth = (this.stamina / this.maxStamina) * barWidth;
                ctx.fillStyle = this.stamina < DASH_COST ? '#ef4444' : '#10b981'; 
                ctx.fillRect(barX, barY, currentWidth, barHeight);
            }

            drawBoostIndicator(ctx) {
                // ... (Existing implementation for Boost Indicator)
                if (this.boostType === 0) return;

                const indicatorColor = this.boostType === 1 ? '#facc15' : '#3b82f6'; // Yellow for Spike, Blue for Power-up
                const indicatorText = this.boostType === 1 ? 'SPIKE!' : 'SUPER JUMP!';
                
                ctx.fillStyle = indicatorColor;
                ctx.font = 'bold 12px Chakra Petch';
                ctx.textAlign = 'center';
                ctx.fillText(indicatorText, this.x, this.y - 30);
                
                // Draw glow effect for player
                ctx.shadowColor = indicatorColor;
                ctx.shadowBlur = 15;
            }

            draw() {
                this.drawStaminaBar(ctx);
                this.drawBoostIndicator(ctx);

                ctx.fillStyle = this.color;
                
                // Apply dash glow if dashing
                if (this.isDashing) {
                    ctx.shadowColor = '#f59e0b'; 
                    ctx.shadowBlur = 20;
                } else if (this.boostType === 0) {
                    // Reset shadow if no boost/dash
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                }

                ctx.beginPath();
                // Body (Rounded Rectangle)
                // ctx.roundRect polyfill/standard: for compatibility, let's use the provided standard
                if (ctx.roundRect) {
                    ctx.roundRect(this.x - this.width / 2, this.y, this.width, this.height, 5);
                } else {
                    // Fallback for older browsers (simple rect)
                    ctx.fillRect(this.x - this.width / 2, this.y, this.width, this.height);
                }
                ctx.fill();

                // Reset shadow before drawing features that shouldn't glow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;

                // Eyes (Small circles for simple face)
                ctx.fillStyle = '#1f2937';
                ctx.beginPath();
                ctx.arc(this.x - 10, this.y + 15, 3, 0, Math.PI * 2);
                ctx.arc(this.x + 10, this.y + 15, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            update() {
                // ... (Existing update logic for physics, stamina, boost)
                // --- 1. Cooldown and State Management ---
                if (this.dashCooldown > 0) {
                    this.dashCooldown--;
                }
                // ‚≠ê CHANGE: Dash only lasts for 1 frame of impulse
                if (this.isDashing) {
                    this.isDashing = false; 
                }

                // --- 2. Stamina Management ---
                const isGrounded = this.y >= Court.floorY - this.height;
                if (isGrounded) {
                    this.stamina = Math.min(this.maxStamina, this.stamina + REGEN_RATE_GROUNDED);
                } else {
                    this.stamina = Math.min(this.maxStamina, this.stamina + REGEN_RATE_AIR);
                }

                // --- 3. Boost Timer ---
                if (this.boostType !== 0) {
                    this.boostTimer--;
                    if (this.boostTimer <= 0) {
                        this.boostType = 0;
                        this.boostTimer = 0;
                    }
                }

                // --- 4. Physics & Movement ---
                // Apply Gravity
                if (this.y < Court.floorY - this.height) {
                    this.dy += GRAVITY;
                    this.isJumping = true;
                } else {
                    this.y = Court.floorY - this.height;
                    this.dy = 0;
                    this.isJumping = false;
                    this.dashCooldown = 0; 
                }

                this.y += this.dy;

                // Horizontal movement
                this.x += this.dx;
                // ‚≠ê NEW FEATURE: Apply air resistance to horizontal movement if not dashing
                if (!this.isDashing && !isGrounded) {
                    this.dx *= 0.98;
                }
                
                // Restrict movement to own side
                const side = this.controls.side;
                if (this.x < Court.playerArea[side].minX + this.width / 2) {
                    this.x = Court.playerArea[side].minX + this.width / 2;
                }
                if (this.x > Court.playerArea[side].maxX - this.width / 2) {
                    this.x = Court.playerArea[side].maxX - this.width / 2;
                }
            }

            jump() {
                // ... (Existing jump logic)
                if (!this.isJumping && this.stamina >= JUMP_COST) {
                    this.stamina -= JUMP_COST;

                    let jumpPower = BASE_JUMP_POWER;
                    
                    // Apply boost power factor
                    if (this.boostType !== 0) {
                        jumpPower *= BOOST_JUMP_FACTOR;
                    }

                    this.dy = -jumpPower;
                    this.isJumping = true;
                    return true; // Return true on successful jump
                }
                return false; // Return false if jump failed
            }
            
            dash() {
                // ... (Existing dash logic)
                if (this.isJumping && this.stamina >= DASH_COST && this.dashCooldown === 0) {
                    this.stamina -= DASH_COST;
                    this.dashCooldown = DASH_COOLDOWN_FRAMES;
                    this.isDashing = true;
                    
                    let dashDir = 0;
                    if (this.dx > 0) dashDir = 1;
                    else if (this.dx < 0) dashDir = -1;
                    else dashDir = (this.controls.side === 'p1') ? 1 : -1; 
                    
                    this.dx = DASH_FORCE_H * dashDir;
                    this.dy = DASH_FORCE_V;
                    
                    if (audioReady) {
                        dashSynth.triggerAttackRelease('16n');
                    }
                    return true;
                }
                return false;
            }
            
            // Method to apply a specific boost
            applyBoost(type) {
                this.boostType = type;
                this.boostTimer = BOOST_TIME;
            }
        }

        class Ball {
            constructor(x, y, radius) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.dx = 0;
                this.dy = 0;
                this.color = '#facc15';
                this.bounceFactor = 0.8;
                this.maxSpeed = 15;
                this.rotation = 0;
                this.rotationSpeed = 0; 
                this.trail = [];
                this.trailLength = 15;
            }
            
            // ‚≠ê NEW FEATURE: Ball Shadow Logic
            drawShadow() {
                if (!ballShadowEl) return;

                const distanceToFloor = Court.floorY - (this.y + this.radius);
                const maxDistance = Court.floorY; 
                
                // Calculate opacity and size based on height
                let opacity = 0;
                let size = this.radius * 2; 

                if (distanceToFloor > 0 && ballInPlay) {
                    // Opacity decreases as distance increases
                    opacity = Math.min(0.7, 1 - (distanceToFloor / (maxDistance * 0.8)));
                    // Size is slightly bigger at max opacity and squashes as it moves away
                    size = this.radius * 2 * (0.8 + 0.2 * (1 - (distanceToFloor / maxDistance))) * 1.5; 
                } else if (distanceToFloor <= 0 && ballInPlay) {
                     // If on the floor, max opacity
                    opacity = 0.7; 
                    size = this.radius * 2 * 1.5;
                }
                
                if (!ballInPlay) opacity = 0;

                // Position the shadow
                const containerRect = canvasContainerEl.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                
                // Calculate position relative to game-container
                // x: Canvas X to DOM X, centered on the ball's X position
                const shadowX = (this.x / CANVAS_WIDTH) * canvasRect.width + canvasRect.left - containerRect.left - size / 2;
                // y: Canvas Floor Y to DOM Y
                const shadowY = (Court.floorY / CANVAS_HEIGHT) * canvasRect.height + canvasRect.top - containerRect.top - (size * 0.25); 

                ballShadowEl.style.left = `${shadowX}px`;
                ballShadowEl.style.top = `${shadowY}px`;
                ballShadowEl.style.width = `${size}px`;
                ballShadowEl.style.height = `${size * 0.5}px`; // Squashed for better look
                ballShadowEl.style.opacity = opacity;
            }

            drawTrail() {
                // ... (Existing trail drawing)
                for (let i = 0; i < this.trail.length; i++) {
                    const { x, y } = this.trail[i];
                    const alpha = 1 - (i / this.trail.length); 
                    const radius = this.radius * (0.8 - i * 0.05); 

                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            draw() {
                // Apply spike flash visual effect
                if (spikeFlashTimer > 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, ' + (spikeFlashTimer / 10) + ')';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 2, 0, Math.PI * 2);
                    ctx.fill();
                    spikeFlashTimer--;
                }

                // Update visual rotation
                this.rotation += this.rotationSpeed * 0.1;

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                // Draw Ball Body
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Simple lines to make it look like a volleyball (rotated)
                ctx.strokeStyle = '#fef3c7';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(-this.radius, 0);
                ctx.lineTo(this.radius, 0);
                ctx.moveTo(0, -this.radius);
                ctx.lineTo(0, this.radius);
                ctx.stroke();

                ctx.restore();
            }

            update() {
                if (!ballInPlay) {
                    this.trail = [];
                    this.rotationSpeed = 0;
                    this.dx = 0;
                    this.dy = 0;
                    return; 
                }

                this.trail.unshift({ x: this.x, y: this.y });
                if (this.trail.length > this.trailLength) {
                    this.trail.pop();
                }

                // ‚≠ê NEW FEATURE: Smoother Wind Implementation
                // Apply wind
                this.dx += windForce; 
                
                // Apply Magnus effect (Spin-induced lift)
                const lift = this.rotationSpeed * this.dx * MAGNUS_FACTOR;
                this.dy -= lift;

                this.dy += GRAVITY;

                // Air Drag/Friction on Spin
                this.rotationSpeed *= (1 - SPIN_AIR_DRAG);

                this.x += this.dx;
                this.y += this.dy;

                this.dx = Math.min(Math.max(this.dx, -this.maxSpeed), this.maxSpeed);
                this.dy = Math.min(Math.max(this.dy, -this.maxSpeed), this.maxSpeed);
            }
        }

        class PowerUp {
            constructor(x, y, radius, type) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.type = type; // 1: Super Jump
                this.color = '#3b82f6'; // Blue Star
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                // Draw a simple star shape
                ctx.fillStyle = this.color;
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.beginPath();
                const points = 5;
                const outerRadius = this.radius;
                const innerRadius = this.radius * 0.4;

                for (let i = 0; i < points * 2; i++) {
                    const angle = Math.PI / points * i;
                    const r = (i % 2) === 0 ? outerRadius : innerRadius;
                    const x = Math.cos(angle - Math.PI / 2) * r;
                    const y = Math.sin(angle - Math.PI / 2) * r;
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }

                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // Add a slight glow
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                ctx.fill();
                ctx.shadowBlur = 0; // Reset shadow

                ctx.restore();
            }

            // Power-ups don't move, so no update method needed
        }

        // Initialize Game Objects
        let player1;
        let player2;
        let ball;

        function resetGame() {
            // Re-initialize players and ball to their starting states
            player1 = new Player(CANVAS_WIDTH / 4, '#facc15', { side: 'p1', left: 'ArrowLeft', right: 'ArrowRight', jump: 'ArrowUp', dash: 'e' });
            player2 = new Player(CANVAS_WIDTH * 3 / 4, '#f87171', { side: 'p2', left: 'a', right: 'd', jump: 'w', dash: 'q' });
            ball = new Ball(CANVAS_WIDTH / 4, Court.floorY - 60 - 20, 10);
            
            // Reset state variables
            ballInPlay = false;
            winningPlayer = null;
            p1Touches = 0; 
            p2Touches = 0; 
            lastPlayerHit = null;
            serveReady = true;
            isPaused = false;
            spikeFlashTimer = 0;
            
            // Reset Scores, Timer, and UI
            player1.score = 0;
            player2.score = 0;
            updateScoreDisplay();
            statusMessageEl.textContent = `Press SPACE to serve (P1 starts)`;
            restartButtonEl.classList.add('hidden');
            gameTimeRemaining = GAME_TIMER_SECONDS;
            updateTimerDisplay();
            
            // Reset Power-up
            powerUp = null;
            powerUpRespawnTimer = 60; // Initial short delay for power-up

            // Reset Wind
            windForce = 0;
            windTargetForce = 0;
            windTimer = 0;
            windIndicatorEl.classList.add('hidden');
        }

        function resetPoint(servingSide) {
            player1.resetPosition();
            player2.resetPosition();
            
            // Set ball position based on the serving side
            const playerToServe = (servingSide === 'p1') ? player1 : player2;
            ball.x = playerToServe.initialX;
            ball.y = playerToServe.initialY - 20;
            ball.dx = 0;
            ball.dy = 0;
            ball.rotationSpeed = 0;

            ballInPlay = false;
            serveReady = true;
            p1Touches = 0;
            p2Touches = 0;
            lastPlayerHit = null;
            lastServeSide = servingSide;

            statusMessageEl.textContent = `Press SPACE to serve (${servingSide === 'p1' ? 'P1' : 'Computer'})`;
        }

        function updateScore(scoringSide) {
            if (winningPlayer) return;
            
            if (scoringSide === 'p1') {
                player1.score++;
                if (audioReady) scoreSynth.triggerAttackRelease('C5', '8n');
                lastServeSide = 'p1';
            } else {
                player2.score++;
                if (audioReady) scoreSynth.triggerAttackRelease('G4', '8n');
                lastServeSide = 'p2';
            }

            updateScoreDisplay();
            
            if (player1.score >= MAX_SCORE || player2.score >= MAX_SCORE) {
                endGame(player1.score > player2.score ? player1 : player2);
                isScoreLimitMode = true; // Win via score limit
            } else {
                resetPoint(lastServeSide);
            }
        }

        function endGame(winner) {
            gameRunning = false;
            winningPlayer = winner;
            const winnerName = winner.controls.side === 'p1' ? 'P1 (Arrows)' : 'Computer';
            statusMessageEl.textContent = `${winnerName} WINS! üéâ`;
            restartButtonEl.classList.remove('hidden');
            if (audioReady) {
                gameEndSynth.triggerAttackRelease(winner.controls.side === 'p1' ? 'C5' : 'G4', '2n');
            }
        }

        function updateScoreDisplay() {
            scoreP1El.textContent = `P1 (Arrows): ${player1.score}`;
            scoreP2El.textContent = `Computer: ${player2.score}`;
        }
        
        function updateTimerDisplay() {
            const minutes = Math.floor(gameTimeRemaining / 60);
            const seconds = gameTimeRemaining % 60;
            gameTimerEl.textContent = 
                `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            
            // Change color when time is low
            if (gameTimeRemaining <= 30 && gameTimeRemaining > 0) {
                gameTimerEl.classList.add('text-red-500');
                gameTimerEl.classList.remove('text-white');
            } else if (gameTimeRemaining <= 0) {
                gameTimerEl.classList.add('text-red-700');
                gameTimerEl.classList.remove('text-red-500');
                gameTimerEl.classList.remove('text-white');
            } else {
                gameTimerEl.classList.remove('text-red-500');
                gameTimerEl.classList.add('text-white');
            }
        }

        // --- Core Game Loop Functions ---

        function drawCourt() {
            // Draw floor
            ctx.fillStyle = COURT_COLOR;
            ctx.fillRect(0, 0, Court.width, Court.floorY);
            ctx.fillStyle = '#10b981';
            ctx.fillRect(0, Court.floorY, Court.width, Court.height - Court.floorY);

            // Draw court lines
            ctx.strokeStyle = LINE_COLOR;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(0, Court.floorY);
            ctx.lineTo(Court.width, Court.floorY);
            ctx.stroke();

            // Draw net post
            ctx.fillStyle = NET_COLOR;
            ctx.fillRect(Court.netX - 2, Court.netY, 4, Court.floorY - Court.netY);
            
            // Draw net top (thicker line)
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.moveTo(Court.netX, Court.netY);
            ctx.lineTo(Court.netX, Court.floorY);
            ctx.stroke();
            
            // Draw net mesh (lines for visual effect)
            ctx.lineWidth = 1;
            ctx.strokeStyle = 'rgba(238, 238, 238, 0.5)';
            for(let i = 1; i < 15; i++) {
                ctx.beginPath();
                ctx.moveTo(Court.netX, Court.netY + (Court.floorY - Court.netY) / 15 * i);
                ctx.lineTo(Court.netX - 10, Court.netY + (Court.floorY - Court.netY) / 15 * i);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(Court.netX, Court.netY + (Court.floorY - Court.netY) / 15 * i);
                ctx.lineTo(Court.netX + 10, Court.netY + (Court.floorY - Court.netY) / 15 * i);
                ctx.stroke();
            }
        }
        
        function updateWind() {
            // --- 1. Manage Wind Timer and Target ---
            if (windTimer > 0) {
                windTimer--;
            } else {
                // New wind phase
                windTargetForce = (Math.random() * 2 - 1) * MAX_WIND_FORCE;
                windTimer = Math.floor(Math.random() * (WIND_DURATION_MAX - WIND_DURATION_MIN) + WIND_DURATION_MIN);
                windIndicatorEl.classList.remove('hidden');
            }

            // --- 2. Smooth Transition ---
            if (Math.abs(windForce - windTargetForce) > windTransitionRate) {
                windForce += Math.sign(windTargetForce - windForce) * windTransitionRate;
            } else {
                windForce = windTargetForce;
            }

            // --- 3. Update Indicator UI ---
            let windDir = windForce > 0 ? 'Right' : (windForce < 0 ? 'Left' : 'Calm');
            let windVal = Math.abs(windForce / MAX_WIND_FORCE);
            let windStr;

            if (windVal < 0.1) {
                windStr = 'Calm';
                windIconEl.textContent = 'üí®';
                windIndicatorEl.style.width = '100px';
            } else if (windVal < 0.5) {
                windStr = `Breeze (${windDir})`;
                windIconEl.textContent = windForce > 0 ? '‚û°Ô∏è' : '‚¨ÖÔ∏è';
                windIndicatorEl.style.width = '140px';
            } else {
                windStr = `Gale (${windDir})`;
                windIconEl.textContent = windForce > 0 ? '‚è©' : '‚è™';
                windIndicatorEl.style.width = '140px';
            }
            
            windStrengthEl.textContent = windStr;

            if (windForce === 0 && windTargetForce === 0) {
                 windIndicatorEl.classList.add('hidden');
            } else {
                windIndicatorEl.classList.remove('hidden');
            }
        }

        function updatePowerUp() {
            if (powerUp) {
                // Check for player collision
                [player1, player2].forEach(player => {
                    const dx = player.x - powerUp.x;
                    const dy = (player.y + player.height / 2) - powerUp.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < player.width/2 + powerUp.radius) {
                        player.applyBoost(2); // Apply Super Jump boost
                        powerUp = null; // Remove power-up
                        powerUpRespawnTimer = Math.floor(Math.random() * (POWERUP_RESPAWN_MAX - POWERUP_RESPAWN_MIN) + POWERUP_RESPAWN_MIN);
                        if (audioReady) powerupSynth.triggerAttackRelease(['C6', 'G6'], '8n');
                    }
                });
            } else {
                // Respawn timer countdown
                powerUpRespawnTimer--;
                if (powerUpRespawnTimer <= 0) {
                    // Create a new Super Jump power-up
                    const x = Math.random() * (CANVAS_WIDTH - 200) + 100; // Somewhere in the top middle
                    const y = Math.random() * 100 + 50; // High in the air
                    powerUp = new PowerUp(x, y, 10, 1);
                    powerUpRespawnTimer = 0; // Stop the countdown until collected
                }
            }
        }
        
        function checkCollisions() {
            // Ball - Floor collision
            if (ball.y + ball.radius >= Court.floorY) {
                ball.y = Court.floorY - ball.radius;
                ball.dy *= -ball.bounceFactor;
                ball.dx *= 0.95; // Ground friction
                ball.rotationSpeed *= 0.8; // Ground stops spin
                
                // Point calculation
                if (ball.x < Court.netX) {
                    // Landed on P1's side -> P2 scores
                    statusMessageEl.textContent = 'Point for Computer!';
                    updateScore('p2');
                } else {
                    // Landed on P2's side -> P1 scores
                    statusMessageEl.textContent = 'Point for P1!';
                    updateScore('p1');
                }
                if (audioReady) hitSynth.triggerAttackRelease(['F3', 'A3'], '16n');
                return; // Point ended, no further checks needed
            }

            // Ball - Net collision
            if (ball.x + ball.radius > Court.netX - 2 && 
                ball.x - ball.radius < Court.netX + 2 && 
                ball.y + ball.radius > Court.netY) {
                
                // Horizontal Net Collision
                if (ball.y < Court.netY) { 
                    // Ball hit the net post/bottom on the side
                    if (ball.x < Court.netX) {
                        ball.x = Court.netX - ball.radius - 2;
                    } else {
                        ball.x = Court.netX + ball.radius + 2;
                    }
                    ball.dx *= -1;
                    ball.dx *= 0.6; // Lose speed on net hit
                    ball.rotationSpeed *= -1; // Reverse spin
                } else {
                    // Ball hit the top of the net
                    ball.y = Court.netY - ball.radius;
                    ball.dy *= -1;
                    ball.dy *= 0.5; // Very soft bounce off the net top
                }

                // A net hit resets touches for the player whose side the ball is on now
                const currentSide = ball.x < Court.netX ? 'p1' : 'p2';
                if (currentSide === 'p1') {
                    p1Touches = 0;
                } else {
                    p2Touches = 0;
                }
                
                if (audioReady) hitSynth.triggerAttackRelease(['A4', 'C5'], '32n');
            }

            // Ball - Wall (side walls and ceiling) collision
            if (ball.x - ball.radius < 0 || ball.x + ball.radius > Court.width) {
                ball.dx *= -1;
                ball.x = ball.x - ball.radius < 0 ? ball.radius : Court.width - ball.radius;
                if (audioReady) hitSynth.triggerAttackRelease(['C4', 'E4'], '64n');
            }
            if (ball.y - ball.radius < 0) {
                ball.dy *= -1;
                ball.y = ball.radius;
                if (audioReady) hitSynth.triggerAttackRelease(['G4', 'B4'], '64n');
            }

            // Player - Ball collision
            [player1, player2].forEach(player => {
                const playerHitboxX = player.x;
                const playerHitboxY = player.y + player.height / 2;
                const hitboxRadius = player.width / 2 + 10; // Wider hit area

                const dx = ball.x - playerHitboxX;
                const dy = ball.y - playerHitboxY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < ball.radius + hitboxRadius) {
                    
                    const side = player.controls.side;
                    let touches = side === 'p1' ? p1Touches : p2Touches;
                    
                    // Check for multiple touches
                    if (player === lastPlayerHit && lastPlayerHit !== null) {
                        // Skip if already hit by the same player in the same frame
                        return;
                    }
                    
                    // Check for illegal touch limit (3 touches)
                    if (touches >= MAX_TOUCHES) {
                        // Illegal touch: opponent scores
                        statusMessageEl.textContent = `${side === 'p1' ? 'P1' : 'Computer'} Illegal Touch! Point for ${side === 'p1' ? 'Computer' : 'P1'}`;
                        updateScore(side === 'p1' ? 'p2' : 'p1');
                        return;
                    }

                    // --- Successful Hit ---
                    ballInPlay = true;
                    serveReady = false;

                    // Update touch count and last hitter
                    if (player.controls.side === 'p1') {
                        p1Touches++;
                        p2Touches = 0;
                    } else {
                        p2Touches++;
                        p1Touches = 0;
                    }
                    lastPlayerHit = player;
                    
                    // Collision response: simple vector reflection/boost
                    const angle = Math.atan2(dy, dx);
                    let newDX = Math.cos(angle) * (ball.radius + hitboxRadius - distance);
                    let newDY = Math.sin(angle) * (ball.radius + hitboxRadius - distance);

                    // Push ball out of player
                    ball.x += newDX * 0.5;
                    ball.y += newDY * 0.5;

                    // New velocity based on player's velocity
                    let playerSpeed = BASE_PLAYER_SPEED;
                    let jumpPower = BASE_JUMP_POWER;
                    
                    // Apply boost factors
                    if (player.boostType !== 0) {
                        playerSpeed *= BOOST_SPEED_FACTOR;
                        jumpPower *= BOOST_JUMP_FACTOR * 0.8; // Smaller jump boost impact on hit
                    }
                    
                    // Calculate ball hit speed
                    let hitSpeedX = player.dx * 0.8; // Player's horizontal momentum contributes
                    let hitSpeedY = player.isJumping ? -jumpPower * 0.8 : ball.dy * 0.8; 
                    
                    // Add impulse from the player to the ball
                    ball.dx = hitSpeedX + Math.cos(angle) * 3;
                    ball.dy = hitSpeedY + Math.sin(angle) * 3;
                    
                    // Check for a powerful spike (high vertical velocity and on the opponent's side)
                    let isSpike = false;
                    const spikeHeightThreshold = Court.netY + ball.radius;
                    if (ball.y < spikeHeightThreshold && 
                        ((side === 'p1' && ball.x > Court.netX) || (side === 'p2' && ball.x < Court.netX))) {
                        
                        // Vertical velocity must be downward and fast
                        if (ball.dy > 5) {
                             // Apply spike force (hard downward and opponent-side speed)
                             const spikeForce = 1.8;
                             ball.dx = (side === 'p1' ? spikeForce : -spikeForce) * 10;
                             ball.dy = 15;
                             player.applyBoost(1); // Spike Boost
                             screenShake(8, 2);
                             spikeFlashTimer = 10;
                             isSpike = true;
                        }
                    }
                    
                    // Calculate spin (based on horizontal velocity change)
                    ball.rotationSpeed += (ball.dx - hitSpeedX) * 2; 

                    // Play sound
                    if (audioReady) {
                        if (isSpike) {
                            spikeSynth.triggerAttackRelease('8n');
                        } else {
                            hitSynth.triggerAttackRelease(['C5', 'E5', 'G5'], '64n');
                        }
                    }
                }
            });
        }
        
        function AI_Logic() {
            if (!gameRunning || isPaused) return;

            const player = player2;
            const courtSide = Court.playerArea.p2;
            const targetX = ball.x;
            const ballProjectionX = ball.x + ball.dx * 5; // Predict ball position in 5 frames
            const ballIsComing = ball.dx < 0 || (ball.x < Court.netX && ball.dx < 0);
            
            // --- 1. Movement Logic ---
            const targetPosition = ballInPlay && ballIsComing ? ballProjectionX : player.initialX;
            const diff = targetPosition - player.x;
            const speed = AI_SETTINGS.getSpeed();

            if (diff > 5) {
                player.dx = speed;
            } else if (diff < -5) {
                player.dx = -speed;
            } else {
                player.dx = 0; // Stop when close to the target x
            }
            
            // AI horizontal clamping: prioritize staying on their side near the net
            if (player.x < courtSide.minX + player.width / 2 + 10) {
                 player.x = courtSide.minX + player.width / 2 + 10;
                 player.dx = Math.max(0, player.dx);
            }
            
            // --- 2. Jump Logic ---
            const ballHitY = ball.y + ball.dy * 1; // Predict ball Y in 1 frame
            const ballIsReachable = Math.abs(diff) < player.width + 10;
            const jumpThreshold = Court.floorY - player.height - AI_SETTINGS.getJumpRange(); // Jump if ball is below this Y-value (closer to the floor)

            if (!player.isJumping && ballInPlay && ballIsReachable) {
                // If ball is low and coming, or high and in the kill zone, jump
                if (ballHitY > jumpThreshold || (ball.y < Court.netY && ball.x > Court.netX)) {
                    player.jump();
                }
            }
            
            // --- 3. Dash Logic (Advanced for higher difficulties) ---
            if (player.isJumping && player.dashCooldown === 0 && player.stamina >= DASH_COST) {
                const dashChance = AI_SETTINGS.getDashChance();
                if (Math.random() < dashChance) {
                    // Check if dash is useful (i.e., will move the player closer to the ball)
                    const dashDirection = player.dx > 0 ? 1 : (player.dx < 0 ? -1 : (player.controls.side === 'p1' ? 1 : -1));
                    const nextX = player.x + DASH_FORCE_H * dashDirection;
                    
                    const distanceBefore = Math.abs(ball.x - player.x);
                    const distanceAfter = Math.abs(ball.x - nextX);

                    // Dash if it significantly closes the distance or is a defensive recovery
                    if (distanceAfter < distanceBefore * 0.5 || (distanceAfter < 50 && ball.dy > 5)) {
                        player.dash();
                    }
                }
            }

            // --- 4. Serve Logic ---
            if (serveReady && lastServeSide === 'p2') {
                // Move towards the serve spot
                if (player.x !== player.initialX) {
                    player.dx = Math.sign(player.initialX - player.x) * speed;
                } else {
                    // Jump and hit
                    if (!player.isJumping && Math.random() < 0.05) { // Small delay
                        player.jump();
                    }
                    if (player.isJumping && player.dy < 0 && Math.random() < 0.1) {
                         // Hit the ball up slightly
                        ballInPlay = true;
                        serveReady = false;
                        player2.isServing = false;
                        lastPlayerHit = player2;
                        p2Touches = 1;
                        p1Touches = 0;
                        
                        ball.dx = -8;
                        ball.dy = -10;
                        ball.rotationSpeed = -5;
                        if (audioReady) hitSynth.triggerAttackRelease(['G5'], '64n');
                        statusMessageEl.textContent = 'Ball in Play!';
                    }
                }
            }
        }

        function screenShake(duration, intensity) {
            screenShakeDuration = duration;
            screenShakeIntensity = intensity;
        }

        function applyScreenShake() {
            if (screenShakeDuration > 0) {
                const offsetX = Math.random() * screenShakeIntensity * 2 - screenShakeIntensity;
                const offsetY = Math.random() * screenShakeIntensity * 2 - screenShakeIntensity;
                
                // Convert canvas coordinates to DOM pixels for translation
                const scaleX = canvasContainerEl.offsetWidth / CANVAS_WIDTH;
                const scaleY = canvasContainerEl.offsetHeight / CANVAS_HEIGHT;

                canvasContainerEl.style.transform = `translate(${offsetX * scaleX}px, ${offsetY * scaleY}px)`;
                screenShakeDuration--;
            } else {
                canvasContainerEl.style.transform = 'translate(0, 0)';
            }
        }

        let lastFrameTime = 0;
        const TARGET_FPS = 60;
        const FRAME_DURATION = 1000 / TARGET_FPS;
        let gameFrameCounter = 0;
        let timerInterval = null;

        function gameLoop(timestamp) {
            if (!gameRunning) return;
            
            // Control frame rate (allows for smoother physics on different machines)
            const elapsed = timestamp - lastFrameTime;

            if (elapsed >= FRAME_DURATION) {
                lastFrameTime = timestamp - (elapsed % FRAME_DURATION);

                if (!isPaused) {
                    updateGameLogic();
                    gameFrameCounter++;
                }
                
                drawGame();
                applyScreenShake();
            }

            requestAnimationFrame(gameLoop);
        }

        function startTimer() {
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                if (isPaused || !gameRunning || winningPlayer) return;
                
                if (gameTimeRemaining > 0) {
                    gameTimeRemaining--;
                    updateTimerDisplay();
                } else {
                    clearInterval(timerInterval);
                    
                    // Time's up! Determine winner by score
                    if (player1.score !== player2.score) {
                        const winner = player1.score > player2.score ? player1 : player2;
                        endGame(winner);
                        isScoreLimitMode = false; // Win via time limit
                    } else {
                         // Tie! Keep playing until next score (sudden death implied)
                        statusMessageEl.textContent = 'TIME OVER! Next point wins (SUDDEN DEATH)';
                        // In a real game, this might force a point reset, but here we just continue until a score happens
                    }
                }
            }, 1000);
        }


        function updateGameLogic() {
            // Player input handled by keydown/keyup events, updated in their update() methods
            
            // AI Logic
            AI_Logic();

            // Object Updates
            player1.update();
            player2.update();
            ball.update();
            
            // Game State Updates
            updateWind();
            updatePowerUp();
            checkCollisions();
        }

        function drawGame() {
            ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

            drawCourt();
            
            // Draw power-up if exists
            if (powerUp) {
                powerUp.draw();
            }

            // Draw player hitboxes first (for a simple visual depth)
            player1.draw();
            player2.draw();

            // Draw ball and trail
            ball.drawTrail();
            ball.draw();
            ball.drawShadow(); // Draw DOM element shadow based on canvas position
        }

        // --- Input Handling ---
        const keys = {};

        document.addEventListener('keydown', (e) => {
            if (isPaused && e.key.toLowerCase() !== 'p') return;

            keys[e.key] = true;

            // Player 1 Controls (Arrows/E)
            if (e.key === player1.controls.left) player1.dx = -BASE_PLAYER_SPEED;
            if (e.key === player1.controls.right) player1.dx = BASE_PLAYER_SPEED;
            if (e.key === player1.controls.jump && !player1.isAI) player1.jump();
            if (e.key.toLowerCase() === player1.controls.dash && !player1.isAI) player1.dash();

            // Game Controls
            if (e.key === ' ' && serveReady && !winningPlayer && lastServeSide === 'p1') {
                // P1 Serve: jump and hit the ball
                if (!player1.isJumping) {
                    player1.jump(); // Player must jump to serve
                }
                
                // Simple serve hit once jumping
                if (player1.isJumping && player1.dy < 0) {
                    ballInPlay = true;
                    serveReady = false;
                    player1.isServing = false;
                    lastPlayerHit = player1;
                    p1Touches = 1;
                    p2Touches = 0;
                    
                    ball.dx = 8;
                    ball.dy = -10;
                    ball.rotationSpeed = 5;
                    if (audioReady) hitSynth.triggerAttackRelease(['C5'], '64n');
                    statusMessageEl.textContent = 'Ball in Play!';
                }
            }

            // Pause toggle
            if (e.key.toLowerCase() === 'p') {
                togglePause();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;

            // Stop movement when key is released
            if (e.key === player1.controls.left && player1.dx < 0) player1.dx = 0;
            if (e.key === player1.controls.right && player1.dx > 0) player1.dx = 0;
        });

        function togglePause() {
            if (winningPlayer) return;
            isPaused = !isPaused;
            if (isPaused) {
                pauseOverlayEl.style.display = 'flex';
                statusMessageEl.textContent = 'Game Paused (P to resume)';
            } else {
                pauseOverlayEl.style.display = 'none';
                statusMessageEl.textContent = ballInPlay ? 'Ball in Play!' : `Press SPACE to serve (${lastServeSide === 'p1' ? 'P1' : 'Computer'})`;
            }
        }


        // --- Event Listeners and Initialization ---
        restartButtonEl.addEventListener('click', () => {
            resetGame();
            gameRunning = true;
            requestAnimationFrame(gameLoop);
            startTimer();
        });
        
        muteButtonEl.addEventListener('click', toggleMute);
        
        // Initial setup on page load
        function initialize() {
            initAudio(); // Initialize audio context
            resetGame(); // Reset game state
            requestAnimationFrame(gameLoop); // Start the game loop
            startTimer(); // Start the game timer
        }

        window.onload = initialize;
    </script>
</body>
</html>