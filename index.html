<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Volleyball Showdown</title>
    <!-- Use Tailwind CDN for the main document structure -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js for Sound Effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* Custom CSS for the Game Canvas and Elements */
        @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght==600;700&display=swap');

        body {
            background-color: #1a202c; /* Dark background */
            font-family: 'Chakra Petch', sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        #game-container {
            border: 8px solid #3c82f6; /* Blue border */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            border-radius: 20px;
            overflow: hidden;
            background-color: #0d1117;
            max-width: 90vw;
            width: 800px; /* Base width */
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative; /* Needed for pause overlay */
        }

        #gameCanvas {
            background-color: #3b82f6; /* Court background */
            display: block;
            width: 100%;
            height: auto; /* Managed by JS to maintain aspect ratio */
            border-radius: 12px 12px 0 0;
        }

        .score-board {
            width: 100%;
            padding: 10px 20px;
            background-color: #1f2937;
            color: #f9f9f9;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.5rem;
            border-radius: 0 0 12px 12px;
            box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.3);
        }

        .controls-info {
            background-color: #1f2937;
            color: #d1d5db;
            padding: 10px;
            margin-top: 20px;
            border-radius: 8px;
            text-align: center;
            font-size: 0.8rem;
            max-width: 800px;
            width: 100%;
        }

        .key {
            display: inline-block;
            background-color: #4b5563;
            color: #ffffff;
            padding: 2px 6px;
            border-radius: 4px;
            margin: 0 2px;
            box-shadow: 0 2px 0 #1f2937;
        }
        
        #restart-button {
            transition: all 0.15s ease-in-out;
            transform: scale(1);
        }
        #restart-button:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(248, 113, 113, 0.4);
        }

        @media (max-width: 640px) {
            .score-board {
                font-size: 1.2rem;
            }
            .controls-info {
                font-size: 0.7rem;
            }
        }
    </style>
</head>
<body>

    <div id="game-container" class="transition-all duration-300">
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        <div class="score-board">
            <div id="score-p1" class="font-bold text-yellow-300">Player 1 (WAD): 0</div>
            
            <div class="flex flex-col items-center">
                <div id="status-message" class="text-center text-sm font-semibold text-white">Press SPACE to serve</div>
                <button id="restart-button" class="mt-1 px-3 py-1 bg-red-600 text-white rounded-lg shadow-md hover:bg-red-700 transition duration-150 hidden">RESTART GAME</button>
            </div>
            
            <div id="score-p2" class="font-bold text-red-400">Computer: 0</div>
        </div>
    </div>
    <div class="controls-info">
        <p class="mb-1">
            <span class="font-bold text-yellow-300">Player 1:</span> Move <span class="key">A</span> <span class="key">D</span>, Jump/Hit <span class="key">W</span>, Pause <span class="key">P</span>
        </p>
        <p>
            <span class="font-bold text-red-400">Computer:</span> **AI Controlled**
        </p>
        <div class="mt-3 text-sm flex items-center justify-center">
            <label for="difficulty-slider" class="mr-3 text-white font-semibold">AI Difficulty:</label>
            <input type="range" id="difficulty-slider" min="1" max="10" value="5" class="w-1/2 h-2 appearance-none bg-gray-600 rounded-full focus:outline-none">
            <span id="difficulty-label" class="ml-3 w-20 text-yellow-300 font-bold text-left">Medium (5)</span>
        </div>
        <p class="mt-2 text-xs text-gray-400">
            **New Features:** **Wind** is now active (check top-left corner)! Spike for a **BOOST**!
        </p>
    </div>

    <script>
        // Game Constants
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 400;
        const COURT_COLOR = '#3b82f6';
        const LINE_COLOR = '#ffffff';
        const NET_COLOR = '#eeeeee';
        const GRAVITY = 0.5;
        const BASE_PLAYER_SPEED = 5;
        const BASE_JUMP_POWER = 12;
        const MAX_SCORE = 5;
        const MAX_TOUCHES = 3; 
        const BOOST_TIME = 180; // 3 seconds at ~60 FPS
        const BOOST_SPEED_FACTOR = 1.5; 
        const BOOST_JUMP_FACTOR = 1.25; 
        
        // Wind Constants
        const WIND_DURATION_MIN = 300; // 5 seconds
        const WIND_DURATION_MAX = 420; // 7 seconds
        const MAX_WIND_FORCE = 0.2; // Max horizontal velocity change per frame

        // AI Settings (Dynamic Difficulty)
        const AI_SETTINGS = {
            level: 5,
            baseSpeed: 4.0, 
            baseJumpRange: 60, 
            
            getSpeed() {
                return this.baseSpeed * (1 + (this.level - 5) * 0.1); 
            },
            getJumpRange() {
                return this.baseJumpRange / (1 + (this.level - 5) * 0.08); 
            }
        };

        // Setup Canvas
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // DOM Elements
        const scoreP1El = document.getElementById('score-p1');
        const scoreP2El = document.getElementById('score-p2');
        const statusMessageEl = document.getElementById('status-message');
        const restartButtonEl = document.getElementById('restart-button');
        
        // DOM Elements for Difficulty Control
        const difficultySliderEl = document.getElementById('difficulty-slider');
        const difficultyLabelEl = document.getElementById('difficulty-label');

        // Audio Initialization
        let hitSynth;
        let scoreSynth;
        let audioReady = false;

        function initAudio() {
            if (audioReady) return;
            
            try {
                // Initialize Tone.js
                hitSynth = new Tone.PolySynth(Tone.AMSynth).toDestination();
                scoreSynth = new Tone.MembraneSynth({
                    pitchDecay: 0.05,
                    octaves: 10,
                    oscillator: { type: "square" },
                    envelope: { attack: 0.001, decay: 0.4, sustain: 0.01 }
                }).toDestination();
                
                // Set up a simple click-to-start mechanism (required for web audio)
                document.documentElement.addEventListener('click', () => {
                    if (Tone.context.state !== 'running') {
                        Tone.start();
                        console.log("Audio Context Started.");
                    }
                }, { once: true });
                
                audioReady = true;
            } catch (error) {
                console.error("Tone.js initialization failed:", error);
            }
        }
        
        // Difficulty Slider Event Listener
        difficultySliderEl.addEventListener('input', (e) => {
            const newLevel = parseInt(e.target.value);
            AI_SETTINGS.level = newLevel;
            
            let labelText = '';
            if (newLevel <= 3) labelText = 'Easy';
            else if (newLevel <= 7) labelText = 'Medium';
            else labelText = 'Hard';
            
            difficultyLabelEl.textContent = `${labelText} (${newLevel})`;
        });


        // Game State
        let gameRunning = true;
        let ballInPlay = false;
        let winningPlayer = null;
        let serveReady = true;
        let p1Touches = 0; 
        let p2Touches = 0; 
        let lastPlayerHit = null; 
        let isPaused = false; 
        
        // Wind State
        let windForce = 0; // Current horizontal force
        let windTimer = 0; // Countdown until wind changes

        // Game Objects
        const Court = {
            width: CANVAS_WIDTH,
            height: CANVAS_HEIGHT,
            netX: CANVAS_WIDTH / 2,
            netHeight: 150,
            floorY: CANVAS_HEIGHT - 20,
            netY: CANVAS_HEIGHT - 20 - 150, // Top of the net
            playerArea: {
                p1: { minX: 0, maxX: CANVAS_WIDTH / 2 - 20 },
                p2: { minX: CANVAS_WIDTH / 2 + 20, maxX: CANVAS_WIDTH }
            }
        };

        class Player {
            constructor(x, color, controls) {
                this.x = x;
                this.y = Court.floorY - 60;
                this.width = 40;
                this.height = 60;
                this.color = color;
                this.score = 0;
                this.dx = 0; 
                this.dy = 0; 
                this.isJumping = false;
                this.isServing = false;
                this.controls = controls; 
                this.isAI = (controls.side === 'p2'); 
                this.isBoosted = false;
                this.boostTimer = 0;
            }

            draw() {
                ctx.fillStyle = this.color;
                
                // Draw glow effect if boosted
                if (this.isBoosted) {
                    ctx.shadowColor = '#3b82f6'; // Electric blue glow
                    ctx.shadowBlur = 15;
                } else {
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                }

                ctx.beginPath();
                // Body (Rounded Rectangle)
                ctx.roundRect(this.x - this.width / 2, this.y, this.width, this.height, 5);
                ctx.fill();

                // Reset shadow before drawing features that shouldn't glow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;

                // Eyes (Small circles for simple face)
                ctx.fillStyle = '#1f2937';
                ctx.beginPath();
                ctx.arc(this.x - 10, this.y + 15, 3, 0, Math.PI * 2);
                ctx.arc(this.x + 10, this.y + 15, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            update() {
                // Handle Boost Timer
                if (this.isBoosted) {
                    this.boostTimer--;
                    if (this.boostTimer <= 0) {
                        this.isBoosted = false;
                        this.boostTimer = 0;
                    }
                }

                // Apply Gravity
                if (this.y < Court.floorY - this.height) {
                    this.dy += GRAVITY;
                    this.isJumping = true;
                } else {
                    this.y = Court.floorY - this.height;
                    this.dy = 0;
                    this.isJumping = false;
                }

                this.y += this.dy;

                // Horizontal movement
                this.x += this.dx;

                // Restrict movement to own side
                const side = this.controls.side;
                if (this.x < Court.playerArea[side].minX + this.width / 2) {
                    this.x = Court.playerArea[side].minX + this.width / 2;
                }
                if (this.x > Court.playerArea[side].maxX - this.width / 2) {
                    this.x = Court.playerArea[side].maxX - this.width / 2;
                }
            }

            jump() {
                if (!this.isJumping) {
                    // Apply jump boost if active
                    let jumpPower = BASE_JUMP_POWER;
                    if (this.isBoosted) {
                        jumpPower *= BOOST_JUMP_FACTOR;
                    }

                    this.dy = -jumpPower;
                    this.isJumping = true;
                }
            }
        }

        class Ball {
            constructor(x, y, radius) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.dx = 0;
                this.dy = 0;
                this.color = '#facc15';
                this.bounceFactor = 0.8;
                this.maxSpeed = 15;
                
                // Trail properties
                this.trail = [];
                this.trailLength = 15;
            }
            
            drawTrail() {
                // Draw fading trail circles
                for (let i = 0; i < this.trail.length; i++) {
                    const { x, y } = this.trail[i];
                    const alpha = 1 - (i / this.trail.length); // Fade out older segments
                    const radius = this.radius * (0.8 - i * 0.05); // Shrink older segments

                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            draw() {
                // Draw Ball
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Simple lines to make it look like a volleyball
                ctx.strokeStyle = '#fef3c7';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(this.x - this.radius, this.y);
                ctx.lineTo(this.x + this.radius, this.y);
                ctx.moveTo(this.x, this.y - this.radius);
                ctx.lineTo(this.x, this.y + this.radius);
                ctx.stroke();
            }

            update() {
                if (!ballInPlay) {
                    // Clear trail when not in play
                    this.trail = [];
                    return; 
                }

                // Update Trail
                this.trail.unshift({ x: this.x, y: this.y });
                if (this.trail.length > this.trailLength) {
                    this.trail.pop();
                }

                // Apply Wind Force
                this.dx += windForce;

                // Apply gravity to vertical velocity
                this.dy += GRAVITY;

                // Update position
                this.x += this.dx;
                this.y += this.dy;

                // Cap speed
                this.dx = Math.min(Math.max(this.dx, -this.maxSpeed), this.maxSpeed);
                this.dy = Math.min(Math.max(this.dy, -this.maxSpeed), this.maxSpeed);

                // Wall collisions (Left/Right)
                if (this.x - this.radius < 0 || this.x + this.radius > Court.width) {
                    this.dx *= -1;
                    this.x = Math.max(this.radius, Math.min(this.x, Court.width - this.radius));
                }

                // Ceiling collision
                if (this.y - this.radius < 0) {
                    this.dy *= -this.bounceFactor;
                    this.y = this.radius;
                }

                // Floor collision (Scoring Logic)
                if (this.y + this.radius > Court.floorY) {
                    this.y = Court.floorY - this.radius;
                    this.dy = 0; // Stop vertical movement
                    this.handleScore();
                }

                // Net collision
                this.handleNetCollision();
            }

            handleNetCollision() {
                const netWidth = 10;
                const netLeft = Court.netX - netWidth / 2;
                const netRight = Court.netX + netWidth / 2;
                const netTop = Court.netY;

                // Check for collision with the net structure
                if (
                    this.x + this.radius > netLeft && this.x - this.radius < netRight &&
                    this.y + this.radius > netTop
                ) {
                    // Ball is hitting the net

                    // 1. Horizontal Bounce (if hitting the side of the net)
                    if (this.x < netLeft && this.dx > 0) { // Hitting left side of net, moving right
                        this.x = netLeft - this.radius;
                        this.dx *= -0.7; // Reduced horizontal bounce
                    } else if (this.x > netRight && this.dx < 0) { // Hitting right side of net, moving left
                        this.x = netRight + this.radius;
                        this.dx *= -0.7;
                    }

                    // 2. Vertical Bounce (if hitting the top edge of the net)
                    if (this.y < netTop && this.dy > 0 && Math.abs(this.x - Court.netX) < netWidth / 2) {
                         this.y = netTop - this.radius;
                         this.dy *= -0.7; // Reduced vertical bounce
                    }

                    // 3. If below the net top, treat it as a dead ball or a strong bounce
                    if (this.y + this.radius > netTop) {
                        // The ball is hitting the main net body
                        if (this.x < Court.netX) { // On left side
                            if (this.dx > 0) this.dx *= -1; // Push it back left
                        } else { // On right side
                            if (this.dx < 0) this.dx *= -1; // Push it back right
                        }
                        this.dx *= 0.5; // Slow down
                    }
                }
            }

            handleScore() {
                ballInPlay = false;
                serveReady = true;
                p1Touches = 0; 
                p2Touches = 0; 
                lastPlayerHit = null; 

                // Reset boosts on score
                p1.isBoosted = false; p1.boostTimer = 0;
                p2.isBoosted = false; p2.boostTimer = 0;


                let scoringPlayer = null;
                const hitFloorX = this.x;

                // Check which side the ball landed on
                if (hitFloorX < Court.netX) {
                    // Landed on Player 1's side (Player 2 scores)
                    scoringPlayer = p2;
                    statusMessageEl.textContent = "Point for Computer (P1 side floor)!";
                } else {
                    // Landed on Player 2's side (Player 1 scores)
                    scoringPlayer = p1;
                    statusMessageEl.textContent = "Point for Player 1 (Computer side floor)!";
                }

                if (scoringPlayer) {
                    scoringPlayer.score++;
                    if (audioReady) {
                        scoreSynth.triggerAttackRelease('C3', '4n', Tone.now(), 0.5);
                    }
                    this.checkWinCondition();
                }
            }

            checkWinCondition() {
                if (p1.score >= MAX_SCORE) {
                    winningPlayer = 'Player 1';
                    gameRunning = false;
                } else if (p2.score >= MAX_SCORE) {
                    winningPlayer = 'Computer';
                    gameRunning = false;
                }

                if (!gameRunning) {
                    statusMessageEl.textContent = `${winningPlayer} Wins! Game Over.`;
                    restartButtonEl.classList.remove('hidden');
                }
            }
        }

        // Initialize Players and Ball
        const p1 = new Player(CANVAS_WIDTH / 4, '#fde047', { up: 'w', left: 'a', right: 'd', side: 'p1' });
        const p2 = new Player(CANVAS_WIDTH * 3 / 4, '#f87171', { up: 'ArrowUp', left: 'ArrowLeft', right: 'ArrowRight', side: 'p2' }); 
        const ball = new Ball(p1.x, p1.y - 40, 15);

        // Input Tracking
        const keysPressed = {};

        document.addEventListener('keydown', (e) => {
            // Toggle pause state with 'P'
            if (e.key === 'p' || e.key === 'P') {
                isPaused = !isPaused;
                if (isPaused) {
                    statusMessageEl.textContent = 'GAME PAUSED. Press P to resume.';
                } else if (!ballInPlay) {
                    // Restore original message if unpaused but ball is not in play
                    const server = (p1.score + p2.score) % 2 === 0 ? p1 : p2;
                    const serverName = server === p1 ? 'Player 1' : 'Computer';
                    statusMessageEl.textContent = `${serverName} to serve. Press SPACE.`;
                }
            }

            if (isPaused) return; 

            keysPressed[e.key] = true;

            // Serve action
            if (e.key === ' ' && !ballInPlay && serveReady) {
                ballInPlay = true;
                serveReady = false;
                
                // Determine server: P1 serves on even points, P2/AI on odd
                const server = (p1.score + p2.score) % 2 === 0 ? p1 : p2;

                if (server.isAI) {
                    server.isServing = true;
                    statusMessageEl.textContent = "Computer Serving...";
                } else {
                    // Human serve logic
                    const initialDx = (ball.x < Court.netX) ? 5 : -5;
                    ball.dx = initialDx * (1 + Math.random() * 0.5); 
                    ball.dy = -10; // Initial upward velocity
                    statusMessageEl.textContent = "Game In Progress!";
                }
            }
        });

        document.addEventListener('keyup', (e) => {
            keysPressed[e.key] = false;
        });

        function handleInput() {
            if (!gameRunning) return;

            // Determine player speed, applying boost if active
            let playerSpeed = BASE_PLAYER_SPEED;
            if (p1.isBoosted) {
                playerSpeed *= BOOST_SPEED_FACTOR;
            }

            // Player 1 (Human) controls
            p1.dx = 0;
            if (keysPressed[p1.controls.left]) p1.dx = -playerSpeed;
            if (keysPressed[p1.controls.right]) p1.dx = playerSpeed;
            if (keysPressed[p1.controls.up]) p1.jump();
        }

        function updateAI(aiPlayer) {
            if (!gameRunning) return;

            // --- Serving Logic ---
            if (!ballInPlay && serveReady) {
                if (aiPlayer.isServing) {
                    ballInPlay = true;
                    serveReady = false;
                    aiPlayer.isServing = false;
                    
                    const initialDx = -6; 
                    ball.dx = initialDx + (Math.random() - 0.5) * 2; 
                    ball.dy = -10 - Math.random() * 3; 
                    statusMessageEl.textContent = "Game In Progress!";
                }
                return; 
            }

            // --- Movement Logic ---
            const targetX = ball.x;
            const aiCenter = aiPlayer.x;
            
            // Apply speed boost if active
            let speed = AI_SETTINGS.getSpeed();
            if (aiPlayer.isBoosted) {
                 speed *= BOOST_SPEED_FACTOR;
            }

            aiPlayer.dx = 0;

            const shouldMove = ballInPlay && (ball.x > Court.netX - 50); 

            if (shouldMove) {
                const distanceToTarget = targetX - aiCenter;
                let moveSpeed = speed;
                if (!aiPlayer.isBoosted) {
                    moveSpeed = Math.min(speed, Math.abs(distanceToTarget) * 0.3); 
                }

                if (distanceToTarget > 5) {
                    aiPlayer.dx = moveSpeed;
                } else if (distanceToTarget < -5) {
                    aiPlayer.dx = -moveSpeed;
                }
            } else {
                // Return to a neutral waiting position 
                const neutralX = Court.width * 3 / 4;
                if (Math.abs(neutralX - aiCenter) > 5) {
                    aiPlayer.dx = (neutralX > aiCenter) ? speed : -speed;
                }
            }
            
            // --- Jumping/Hitting Logic ---
            const horizontalDistance = Math.abs(ball.x - aiPlayer.x);
            const verticalReach = aiPlayer.y - ball.y; 

            const ballInAIArea = ball.x > Court.netX;
            const jumpThreshold = AI_SETTINGS.getJumpRange(); 

            if (ballInPlay && ballInAIArea && !aiPlayer.isJumping) {
                const canReachHorizontally = horizontalDistance < jumpThreshold;

                if (canReachHorizontally) {
                    // Check for a spike opportunity 
                    const isSpikeOpportunity = ball.dy > 1.5 && ball.y < Court.netY + ball.radius; 
                    
                    const spikeChance = AI_SETTINGS.level / 10; 

                    if (isSpikeOpportunity && Math.random() < spikeChance) { 
                        aiPlayer.jump();
                    } 
                    // Otherwise, jump if the ball is within a good vertical window
                    else if (verticalReach > 0 && verticalReach < aiPlayer.height * 2) { 
                        aiPlayer.jump();
                    }
                }
            }
        }
        
        // --- Wind Mechanic ---
        function updateWind() {
            windTimer--;
            if (windTimer <= 0) {
                // Change wind force randomly between -MAX_WIND_FORCE and +MAX_WIND_FORCE
                windForce = (Math.random() * (MAX_WIND_FORCE * 2) - MAX_WIND_FORCE) * 0.5;
                // Set new timer duration
                windTimer = WIND_DURATION_MIN + Math.random() * (WIND_DURATION_MAX - WIND_DURATION_MIN);
            }
        }

        function handleFoul(foulingPlayerId) {
            ballInPlay = false;
            serveReady = true;

            let scoringPlayer = (foulingPlayerId === 'p1') ? p2 : p1;
            const foulText = `FOUL! ${foulingPlayerId === 'p1' ? 'Player 1' : 'Computer'} exceeded ${MAX_TOUCHES} touches.`;
            const scoreText = `Point for ${scoringPlayer === p1 ? 'Player 1' : 'Computer'}!`;
            
            p1.isBoosted = false; p1.boostTimer = 0;
            p2.isBoosted = false; p2.boostTimer = 0;

            scoringPlayer.score++;
            if (audioReady) {
                scoreSynth.triggerAttackRelease('C2', '2n', Tone.now(), 0.5);
            }
            statusMessageEl.textContent = `${foulText} ${scoreText}`;

            p1Touches = 0;
            p2Touches = 0;
            lastPlayerHit = null;

            ball.checkWinCondition();
        }

        function checkPlayerBallCollision(player, ball) {
            // Simple AABB vs Circle check
            const closestX = Math.max(player.x - player.width / 2, Math.min(ball.x, player.x + player.width / 2));
            const closestY = Math.max(player.y, Math.min(ball.y, player.y + player.height));

            const distanceX = ball.x - closestX;
            const distanceY = ball.y - closestY;
            const distanceSq = (distanceX * distanceX) + (distanceY * distanceY);

            if (distanceSq < (ball.radius * ball.radius)) {
                // Collision detected!

                const playerId = (player === p1) ? 'p1' : 'p2';
                const opponentId = (player === p1) ? 'p2' : 'p1';

                // 1. TOUCH COUNT LOGIC
                if (lastPlayerHit === opponentId) {
                    p1Touches = (player === p1) ? 1 : 0;
                    p2Touches = (player === p2) ? 1 : 0;
                } else {
                    if (player === p1) p1Touches++;
                    else p2Touches++;
                }
                
                // Check for Triple Touch Foul
                if ((player === p1 && p1Touches > MAX_TOUCHES) || (player === p2 && p2Touches > MAX_TOUCHES)) {
                    handleFoul(playerId);
                    return; 
                }

                // 2. SPIKE/BOOST LOGIC
                let powerBoost = 1.0;
                const isSpike = player.isJumping && player.dy > 0 && ball.y < Court.netY + ball.radius;

                if (isSpike) {
                    // Trigger Power Boost for the hitting player
                    player.isBoosted = true;
                    player.boostTimer = BOOST_TIME;

                    powerBoost = 1.5;
                    const hitterName = playerId === 'p1' ? 'Player 1' : 'Computer';
                    statusMessageEl.textContent = `${hitterName} SPIKE BOOST!`;
                } else if (ballInPlay) {
                    const hitterName = playerId === 'p1' ? 'Player 1' : 'Computer';
                    statusMessageEl.textContent = `Hit ${player === p1 ? p1Touches : p2Touches} for ${hitterName}!`;
                }
                
                // 3. SOUND EFFECT
                if (audioReady) {
                    const note = isSpike ? 'G5' : 'C5'; 
                    hitSynth.triggerAttackRelease(note, '16n');
                }
                
                // 4. PHYSICS RESOLUTION
                const speed = Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy);
                const impactForce = 1.0; 

                let normalX = ball.x - closestX;
                let normalY = ball.y - closestY;
                const normalLength = Math.sqrt(normalX * normalX + normalY * normalY);
                normalX /= normalLength;
                normalY /= normalLength;

                let newDx = normalX * speed * impactForce + player.dx * 0.5;
                let newDy = normalY * speed * impactForce + player.dy * 0.5;

                // Push ball out of player's bounds
                const overlap = ball.radius - normalLength;
                ball.x += normalX * overlap * 1.5;
                ball.y += normalY * overlap * 1.5;

                // Apply new velocity
                ball.dx = newDx * powerBoost * (isSpike ? 1.2 : 1.0); 
                ball.dy = newDy * powerBoost;

                // Ensure a minimum upward velocity for better gameplay feel
                if (ball.dy > -5) ball.dy = -5;

                // Enforce max speed after boost
                ball.dx = Math.min(Math.max(ball.dx, -ball.maxSpeed), ball.maxSpeed);
                ball.dy = Math.min(Math.max(ball.dy, -ball.maxSpeed), ball.maxSpeed);

                // Update last touch
                lastPlayerHit = playerId;
            }
        }
        
        // --- Game Utility Functions ---

        function resetGame() {
            p1.score = 0;
            p2.score = 0;
            p1.x = CANVAS_WIDTH / 4;
            p2.x = CANVAS_WIDTH * 3 / 4;
            
            // Reset boosts
            p1.isBoosted = false; p1.boostTimer = 0;
            p2.isBoosted = false; p2.boostTimer = 0;
            
            // Set ball to starting server (P1 for start)
            ball.x = p1.x;
            ball.y = p1.y - 40;
            ball.dx = 0;
            ball.dy = 0;

            gameRunning = true;
            ballInPlay = false;
            serveReady = true;
            isPaused = false;
            p1Touches = 0;
            p2Touches = 0;
            lastPlayerHit = null;
            winningPlayer = null;
            
            // Set first server
            const server = (p1.score + p2.score) % 2 === 0 ? p1 : p2;
            server.isServing = true;
            const serverName = server === p1 ? 'Player 1' : 'Computer';
            
            statusMessageEl.textContent = `${serverName} to serve. Press SPACE.`;
            restartButtonEl.classList.add('hidden');
        }
        
        // Add listener for the new restart button
        restartButtonEl.addEventListener('click', resetGame);


        // --- Drawing Functions ---

        function drawCourt() {
            // Draw Court Floor
            ctx.fillStyle = COURT_COLOR;
            ctx.fillRect(0, Court.floorY, Court.width, Court.height - Court.floorY);

            // Draw Court Line (Floor)
            ctx.strokeStyle = LINE_COLOR;
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(0, Court.floorY);
            ctx.lineTo(Court.width, Court.floorY);
            ctx.stroke();

            // Draw Net
            ctx.fillStyle = NET_COLOR;
            const netWidth = 10;
            const netX = Court.netX - netWidth / 2;
            const netHeight = Court.netHeight;
            const netY = Court.floorY - netHeight;

            // Net posts
            ctx.fillRect(netX, netY, netWidth, netHeight);

            // Net mesh (simplified)
            ctx.strokeStyle = '#aaaaaa';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let i = 0; i < 5; i++) {
                ctx.moveTo(netX, netY + i * (netHeight / 4));
                ctx.lineTo(netX + netWidth, netY + i * (netHeight / 4));
            }
            ctx.stroke();

            // Center dividing line (under the net)
            ctx.strokeStyle = LINE_COLOR;
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(Court.netX, netY);
            ctx.lineTo(Court.netX, Court.floorY);
            ctx.stroke();
        }
        
        function drawWindIndicator() {
            if (Math.abs(windForce) < 0.01) return; // Only draw if significant wind

            ctx.font = 'bold 20px Chakra Petch';
            ctx.textAlign = 'left';
            
            // Color based on direction (Green for Left, Orange for Right)
            ctx.fillStyle = windForce > 0 ? '#f97316' : '#10b981'; 

            let windStrength = Math.round(Math.abs(windForce) * 100);
            const windArrow = windForce > 0 ? '→' : '←';
            const windText = `WIND ${windArrow} (${windStrength})`;
            
            ctx.fillText(windText, 10, 30);
        }

        function drawPauseOverlay() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 48px Chakra Petch';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('GAME PAUSED', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);

            ctx.font = '24px Chakra Petch';
            ctx.fillText('Press P to Resume', CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2 + 50);
        }


        function draw() {
            // Clear Canvas
            ctx.clearRect(0, 0, Court.width, Court.height);
            
            // 1. Draw Ball Trail (should be behind players and court)
            ball.drawTrail();

            // 2. Draw Court
            drawCourt();

            // 3. Draw Players
            p1.draw();
            p2.draw();

            // 4. Draw Ball
            ball.draw();

            // 5. Draw Wind Indicator
            drawWindIndicator();

            // 6. Draw Pause Overlay (if paused)
            if (isPaused) {
                drawPauseOverlay();
            }

            // Update Scoreboard is handled outside the canvas draw loop
            scoreP1El.textContent = `Player 1 (WAD): ${p1.score}`;
            scoreP2El.textContent = `Computer: ${p2.score}`;
        }

        // --- Game Loop ---

        function update() {
            if (gameRunning && !isPaused) { 
                // 1. Update Environment
                updateWind();
                
                // 2. Handle Input (Human Player 1)
                handleInput();

                // 3. Handle AI (Computer Player 2)
                updateAI(p2);

                // 4. Update Game Objects
                p1.update();
                p2.update();

                // If ball is not in play, keep it above the server
                if (!ballInPlay) {
                    const server = (p1.score + p2.score) % 2 === 0 ? p1 : p2; 
                    
                    ball.x = server.x; 
                    ball.y = server.y - 40;
                    ball.dx = 0;
                    ball.dy = 0;
                    
                    if (server.isAI && serveReady) {
                        server.isServing = true;
                    }

                    if (serveReady && !server.isAI) {
                        statusMessageEl.textContent = `Player 1 to serve. Press SPACE.`;
                    }
                } else {
                    ball.update();

                    // 5. Collision Checks
                    checkPlayerBallCollision(p1, ball);
                    checkPlayerBallCollision(p2, ball);
                }
            }

            // 6. Draw (Always draw, even when paused)
            draw();

            // Request next frame
            requestAnimationFrame(update);
        }

        // Start the game loop on window load
        window.onload = function () {
            // Initialize audio on first user interaction
            initAudio(); 
            // Set initial server
            p1.isServing = true;
            // Initialize wind immediately
            updateWind();
            requestAnimationFrame(update);
        }

    </script>
</body>
</html>
