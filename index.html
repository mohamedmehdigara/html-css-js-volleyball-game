<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2D Volleyball Showdown</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* Custom CSS for the Game Canvas and Elements */
        @import url('https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@600;700&display=swap');

        body {
            background-color: #1a202c; /* Dark background */
            font-family: 'Chakra Petch', sans-serif;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }

        #game-container {
            border: 8px solid #3c82f6; /* Blue border */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            border-radius: 20px;
            overflow: hidden;
            background-color: #0d1117;
            max-width: 90vw;
            width: 800px; /* Base width */
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative; /* Needed for screen shake */
            transition: all 0.1s ease;
        }

        #gameCanvas {
            background-color: #3b82f6; /* Court background */
            display: block;
            width: 100%;
            height: auto; /* Managed by JS to maintain aspect ratio */
            border-radius: 12px 12px 0 0;
        }

        .score-bar-container {
            width: 100%;
            padding: 10px 20px;
            background-color: #1f2937;
            color: #f9f9f9;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 1.5rem;
            border-radius: 0 0 12px 12px;
            box-shadow: 0 -4px 10px rgba(0, 0, 0, 0.3);
        }

        .controls-info {
            background-color: #1f2937;
            color: #d1d5db;
            padding: 10px;
            margin-top: 20px;
            border-radius: 8px;
            text-align: center;
            font-size: 0.8rem;
            max-width: 800px;
            width: 100%;
        }

        .key {
            display: inline-block;
            background-color: #4b5563;
            color: #ffffff;
            padding: 2px 6px;
            border-radius: 4px;
            margin: 0 2px;
            box-shadow: 0 2px 0 #1f2937;
        }
        
        #restart-button, #mute-button {
            transition: all 0.15s ease-in-out;
            transform: scale(1);
        }
        #restart-button:hover, #mute-button:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 15px rgba(248, 113, 113, 0.4);
        }
        
        /* Custom styles for the mute button icon (simple speaker) */
        #mute-button svg {
            width: 20px;
            height: 20px;
        }

        /* ‚≠ê NEW FEATURE: Game Pause Overlay Style */
        #pause-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-size: 3rem;
            font-weight: bold;
            z-index: 10;
        }
        /* ‚≠ê NEW FEATURE: Ball Shadow Style */
        .ball-shadow {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.1s;
            pointer-events: none;
        }
        /* ‚≠ê NEW FEATURE: Wind Indicator Style */
        #wind-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 100px;
            height: 20px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            color: white;
            font-size: 0.8rem;
            line-height: 20px;
            text-align: center;
            z-index: 5;
            padding: 0 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 5px;
        }


        @media (max-width: 640px) {
            .score-bar-container {
                font-size: 1.2rem;
                padding: 8px 10px;
            }
            .controls-info {
                font-size: 0.7rem;
            }
        }
    </style>
</head>
<body>

    <div id="game-container" class="transition-all duration-300">
        <canvas id="gameCanvas" width="800" height="400"></canvas>
        
        <div id="pause-overlay">
            PAUSED
            <span class="text-lg mt-4 font-normal">Press P to resume</span>
        </div>
        
        <div id="wind-indicator" class="hidden">
            <span id="wind-icon">üå¨Ô∏è</span>
            <span id="wind-strength">Calm</span>
        </div>

        <div class="score-bar-container">
            <div id="score-p1" class="font-bold text-yellow-300">P1 (Arrows): 0</div>
            
            <div class="flex flex-col items-center flex-grow mx-4">
                <div id="game-timer" class="text-2xl font-extrabold text-white mb-1">05:00</div>
                <div id="status-message" class="text-center text-sm font-semibold text-white">Press SPACE to serve</div>
                <div class="flex mt-1 space-x-2">
                    <button id="restart-button" class="px-3 py-1 bg-red-600 text-white rounded-lg shadow-md hover:bg-red-700 transition duration-150 hidden">RESTART GAME</button>
                    <button id="mute-button" class="px-2 py-1 bg-gray-600 text-white rounded-lg shadow-md hover:bg-gray-500 transition duration-150">
                        <svg id="mute-icon-unmuted" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M18.784 4.25c.346.126.65.313.916.556C20.407 6.273 21 8.243 21 10.25a11.16 11.16 0 0 1-1.385 5.564c-.266.243-.57.43-.916.556a8.88 8.88 0 0 0 0-6.17c-.346-.126-.65-.313-.916-.556A10.165 10.165 0 0 0 17 10.25c0-.655.088-1.294.246-1.9.157-.606.39-1.18.683-1.706a7.882 7.882 0 0 1-.683-1.706c-.158-.606-.39-1.18-.683-1.706-.293-.526-.626-.976-.997-1.35C16.52 3.868 17 3.25 17 2.5a.75.75 0 0 0-.75-.75h-2.5a.75.75 0 0 0-.75.75c0 .75.52 1.368 1.184 1.634.346.126.65.313.916.556a8.88 8.88 0 0 0 0 6.17ZM17 10.25a.75.75 0 0 0 1.5 0v-.5a.75.75 0 0 0-1.5 0v.5Z" />
                            <path fill-rule="evenodd" d="M12.28 1.28a.75.75 0 0 0-1.06 0l-7.5 7.5A.75.75 0 0 0 3 9.39V15a3 3 0 0 0 3 3h2.15l.48.567a.75.75 0 0 0 1.05.006l4.68-5.748a.75.75 0 0 0 .006-1.05Z" clip-rule="evenodd" />
                        </svg>
                        <svg id="mute-icon-muted" class="hidden" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                            <path d="M13.28 1.28a.75.75 0 0 0-1.06 0l-7.5 7.5A.75.75 0 0 0 3 9.39V15a3 3 0 0 0 3 3h2.15l.48.567a.75.75 0 0 0 1.05.006l4.68-5.748a.75.75 0 0 0 .006-1.05L13.28 1.28Z" />
                            <path fill-rule="evenodd" d="M19.057 4.293a.75.75 0 0 0-1.06-1.06l-1.97 1.97L15.057 3.23a.75.75 0 0 0-1.06 1.06l1.97 1.97-1.97 1.97a.75.75 0 1 0 1.06 1.06l1.97-1.97 1.97 1.97a.75.75 0 1 0 1.06-1.06l-1.97-1.97 1.97-1.97a.75.75 0 0 0 0-1.06Z" clip-rule="evenodd" />
                        </svg>
                    </button>
                </div>
            </div>
            
            <div id="score-p2" class="font-bold text-red-400">Computer: 0</div>
        </div>
    </div>
    <div class="controls-info">
        <p class="mb-1">
            <span class="font-bold text-yellow-300">Player 1:</span> Move <span class="key">‚Üê</span> <span class="key">‚Üí</span>, Jump/Hit <span class="key">‚Üë</span>, Air Dash <span class="key">E</span>, Pause <span class="key">P</span>
        </p>
        <p>
            <span class="font-bold text-red-400">Computer:</span> **AI Controlled** (Uses Dash Strategically)
        </p>
        <p class="mt-2 text-sm text-yellow-300">
            **New:** Look for the **Super Jump Power-Up** (Blue Star) to jump higher!
        </p>
        <div class="mt-3 text-sm flex items-center justify-center">
            <label for="difficulty-slider" class="mr-3 text-white font-semibold">AI Difficulty:</label>
            <input type="range" id="difficulty-slider" min="1" max="10" value="5" class="w-1/2 h-2 appearance-none bg-gray-600 rounded-full focus:outline-none">
            <span id="difficulty-label" class="ml-3 w-20 text-yellow-300 font-bold text-left">Medium (5)</span>
        </div>
        <p class="mt-2 text-xs text-gray-400">
            Features: **Game Timer (5 min)**, **Super Jump Power-Up**, **Mid-Air Dash**, **Ball Spin (Magnus Effect)**, **Dynamic Wind**, **Ball Shadow**, **AI Difficulty**, **Spike Flash**, **Pause Screen**.
        </p>
    </div>

    <script>
        // Game Constants
        const CANVAS_WIDTH = 800;
        const CANVAS_HEIGHT = 400;
        const COURT_COLOR = '#3b82f6';
        const LINE_COLOR = '#ffffff';
        const NET_COLOR = '#eeeeee';
        const GRAVITY = 0.5;
        const BASE_PLAYER_SPEED = 5;
        const BASE_JUMP_POWER = 12;
        const MAX_SCORE = 5;
        const MAX_TOUCHES = 3; 
        
        // Timer Constant (5 minutes)
        const GAME_TIMER_SECONDS = 5 * 60; 

        // Boost Constants (used for Spikes and Power-Ups)
        const BOOST_TIME = 360; // 6 seconds at ~60 FPS
        const BOOST_SPEED_FACTOR = 1.3; 
        const BOOST_JUMP_FACTOR = 1.6; // Higher factor for the power-up effect

        // Power-Up Constants
        const POWERUP_RESPAWN_MIN = 60 * 5; // 5 seconds
        const POWERUP_RESPAWN_MAX = 60 * 15; // 15 seconds
        const POWERUP_COLOR = '#34d399'; // Green/Teal

        // Stamina Constants
        const MAX_STAMINA = 100;
        const JUMP_COST = 30;
        const REGEN_RATE_GROUNDED = 2;
        const REGEN_RATE_AIR = 0.5;
        
        // Air Dash Constants
        const DASH_COST = 40;
        const DASH_COOLDOWN_FRAMES = 60; // 1 second cooldown
        const DASH_FORCE_H = 15;
        const DASH_FORCE_V = -5; 
        
        // Wind Constants
        const WIND_DURATION_MIN = 300; 
        const WIND_DURATION_MAX = 420; 
        const MAX_WIND_FORCE = 0.2; 
        
        // Ball Spin Constants (Magnus Effect Approximation)
        const SPIN_AIR_DRAG = 0.005; 
        const MAGNUS_FACTOR = 0.008; 

        // Screen Shake State
        let screenShakeDuration = 0;
        let screenShakeIntensity = 0;
        let canvasContainerEl = document.getElementById('game-container');
        
        // AI Settings (Dynamic Difficulty)
        const AI_SETTINGS = {
            level: 5,
            baseSpeed: 4.0, 
            baseJumpRange: 60, 
            
            getSpeed() {
                // ‚≠ê NEW FEATURE: Make AI speed slightly dynamic based on difficulty
                return this.baseSpeed * (1 + (this.level - 5) * 0.1); 
            },
            getJumpRange() {
                // ‚≠ê NEW FEATURE: Make AI jump reaction time dynamic based on difficulty
                return this.baseJumpRange / (1 + (this.level - 5) * 0.08); 
            },
            // ‚≠ê NEW FEATURE: New AI property for dash strategy
            getDashChance() {
                return (this.level - 1) * 0.02; // 0% at level 1, up to 18% at level 10
            }
        };

        // Setup Canvas
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        // DOM Elements
        const scoreP1El = document.getElementById('score-p1');
        const scoreP2El = document.getElementById('score-p2');
        const statusMessageEl = document.getElementById('status-message');
        const restartButtonEl = document.getElementById('restart-button');
        const muteButtonEl = document.getElementById('mute-button');
        const muteIconUnmutedEl = document.getElementById('mute-icon-unmuted');
        const muteIconMutedEl = document.getElementById('mute-icon-muted');
        const gameTimerEl = document.getElementById('game-timer');
        const pauseOverlayEl = document.getElementById('pause-overlay'); // ‚≠ê NEW FEATURE: Pause Overlay DOM
        const windIndicatorEl = document.getElementById('wind-indicator'); // ‚≠ê NEW FEATURE: Wind Indicator DOM
        const windStrengthEl = document.getElementById('wind-strength'); // ‚≠ê NEW FEATURE: Wind Indicator DOM
        const windIconEl = document.getElementById('wind-icon'); // ‚≠ê NEW FEATURE: Wind Indicator DOM
        
        // DOM Elements for Difficulty Control
        const difficultySliderEl = document.getElementById('difficulty-slider');
        const difficultyLabelEl = document.getElementById('difficulty-label');

        // Audio Initialization
        let hitSynth;
        let scoreSynth;
        let spikeSynth;
        let dashSynth;
        let powerupSynth;
        // ‚≠ê NEW FEATURE: New sound for Game Over
        let gameEndSynth; 
        let audioReady = false;
        let isMuted = false;

        function initAudio() {
            if (audioReady) return;
            
            try {
                // Initialize Tone.js
                hitSynth = new Tone.PolySynth(Tone.AMSynth, { volume: -10 }).toDestination();
                scoreSynth = new Tone.MembraneSynth({
                    pitchDecay: 0.05,
                    octaves: 10,
                    oscillator: { type: "square" },
                    envelope: { attack: 0.001, decay: 0.4, sustain: 0.01 }
                }).toDestination();
                
                spikeSynth = new Tone.NoiseSynth({
                    noise: { type: 'white' },
                    envelope: { attack: 0.005, decay: 0.1, sustain: 0, release: 0.1 },
                    volume: -5
                }).toDestination();

                dashSynth = new Tone.NoiseSynth({
                    noise: { type: 'pink' },
                    envelope: { attack: 0.01, decay: 0.05, sustain: 0, release: 0.05 },
                    volume: -8
                }).toDestination();
                
                powerupSynth = new Tone.Synth({
                    oscillator: { type: "triangle" },
                    envelope: { attack: 0.05, decay: 0.1, sustain: 0.2, release: 0.1 },
                    volume: -5
                }).toDestination();
                
                // ‚≠ê NEW FEATURE: Game End Sound
                gameEndSynth = new Tone.Synth({
                    oscillator: { type: "sawtooth" },
                    envelope: { attack: 0.05, decay: 0.5, sustain: 0, release: 1 },
                    volume: -3
                }).toDestination();
                
                // Set up a simple click-to-start mechanism (required for web audio)
                document.documentElement.addEventListener('click', () => {
                    if (Tone.context.state !== 'running') {
                        Tone.start();
                    }
                }, { once: true });
                
                audioReady = true;
            } catch (error) {
                console.error("Tone.js initialization failed:", error);
            }
        }
        
        function toggleMute() {
            isMuted = !isMuted;
            Tone.Master.mute = isMuted;

            if (isMuted) {
                muteButtonEl.classList.replace('bg-gray-600', 'bg-red-700');
                muteIconUnmutedEl.classList.add('hidden');
                muteIconMutedEl.classList.remove('hidden');
            } else {
                muteButtonEl.classList.replace('bg-red-700', 'bg-gray-600');
                muteIconUnmutedEl.classList.remove('hidden');
                muteIconMutedEl.classList.add('hidden');
            }
        }
        
        // Difficulty Slider Event Listener
        difficultySliderEl.addEventListener('input', (e) => {
            const newLevel = parseInt(e.target.value);
            AI_SETTINGS.level = newLevel;
            
            let labelText = '';
            let labelColor = 'text-yellow-300';
            if (newLevel <= 3) { labelText = 'Easy'; labelColor = 'text-green-400'; }
            else if (newLevel <= 7) { labelText = 'Medium'; labelColor = 'text-yellow-300'; }
            else { labelText = 'Hard'; labelColor = 'text-red-500'; }
            
            difficultyLabelEl.textContent = `${labelText} (${newLevel})`;
            difficultyLabelEl.className = `ml-3 w-20 font-bold text-left ${labelColor}`;
        });

        // Game State
        let gameRunning = true;
        let ballInPlay = false;
        let winningPlayer = null;
        let serveReady = true;
        let p1Touches = 0; 
        let p2Touches = 0; 
        let lastPlayerHit = null; 
        let isPaused = false; 
        let gameTimeRemaining = GAME_TIMER_SECONDS;
        // ‚≠ê NEW FEATURE: Track serve side
        let lastServeSide = 'p1'; 

        // Wind State
        let windForce = 0; 
        let windTimer = 0; 
        // ‚≠ê NEW FEATURE: Smoother Wind Transition
        let windTargetForce = 0;
        let windTransitionRate = 0.005;
        
        // Spike Visual State
        let spikeFlashTimer = 0; 

        // Power-up State
        let powerUp = null;
        let powerUpRespawnTimer = 0;

        // ‚≠ê NEW FEATURE: Score Limit Mode vs Time Limit Mode
        let isScoreLimitMode = true; // Initially true
        // If MAX_SCORE is reached, win. If timer runs out, win by score difference.

        // Game Objects
        const Court = {
            width: CANVAS_WIDTH,
            height: CANVAS_HEIGHT,
            netX: CANVAS_WIDTH / 2,
            netHeight: 150,
            floorY: CANVAS_HEIGHT - 20,
            netY: CANVAS_HEIGHT - 20 - 150, // Top of the net
            playerArea: {
                p1: { minX: 0, maxX: CANVAS_WIDTH / 2 - 20 },
                p2: { minX: CANVAS_WIDTH / 2 + 20, maxX: CANVAS_WIDTH }
            }
        };

        class Player {
            constructor(x, color, controls) {
                this.initialX = x; // ‚≠ê NEW FEATURE: Initial position for reset
                this.initialY = Court.floorY - 60; // ‚≠ê NEW FEATURE: Initial position for reset
                this.x = x;
                this.y = Court.floorY - 60;
                this.width = 40;
                this.height = 60;
                this.color = color;
                this.score = 0;
                this.dx = 0; 
                this.dy = 0; 
                this.isJumping = false;
                this.isServing = false;
                this.controls = controls; 
                this.isAI = (controls.side === 'p2'); 
                
                // Boost state: 0=none, 1=Spike Boost, 2=Power-up Boost
                this.boostType = 0; 
                this.boostTimer = 0;
                
                // Stamina properties
                this.stamina = MAX_STAMINA;
                this.maxStamina = MAX_STAMINA;
                
                // Dash properties
                this.dashCooldown = 0;
                this.isDashing = false;
            }

            // ‚≠ê NEW FEATURE: Reset method for cleaner score resets
            resetPosition() {
                this.x = this.initialX;
                this.y = this.initialY;
                this.dx = 0;
                this.dy = 0;
                this.isJumping = false;
                this.isServing = false;
                this.boostType = 0;
                this.boostTimer = 0;
                this.stamina = this.maxStamina;
                this.dashCooldown = 0;
            }


            drawStaminaBar(ctx) {
                // ... (Existing implementation for Stamina Bar)
                const barWidth = this.width * 1.5;
                const barHeight = 5;
                const barX = this.x - barWidth / 2;
                const barY = this.y - 15; 

                // Background (Empty)
                ctx.fillStyle = '#4b5563';
                ctx.fillRect(barX, barY, barWidth, barHeight);

                // Cooldown Overlay (if dashing)
                if (this.dashCooldown > 0) {
                    const cdRatio = this.dashCooldown / DASH_COOLDOWN_FRAMES;
                    ctx.fillStyle = `rgba(249, 115, 22, ${cdRatio * 0.7})`; 
                    ctx.fillRect(barX, barY, barWidth, barHeight);
                }

                // Foreground (Stamina)
                const currentWidth = (this.stamina / this.maxStamina) * barWidth;
                ctx.fillStyle = this.stamina < DASH_COST ? '#ef4444' : '#10b981'; 
                ctx.fillRect(barX, barY, currentWidth, barHeight);
            }

            drawBoostIndicator(ctx) {
                // ... (Existing implementation for Boost Indicator)
                if (this.boostType === 0) return;

                const indicatorColor = this.boostType === 1 ? '#facc15' : POWERUP_COLOR; 
                const indicatorText = this.boostType === 1 ? 'SPIKE!' : 'SUPER JUMP!';
                
                ctx.fillStyle = indicatorColor;
                ctx.font = 'bold 12px Chakra Petch';
                ctx.textAlign = 'center';
                ctx.fillText(indicatorText, this.x, this.y - 30);
                
                // Draw glow effect for player
                ctx.shadowColor = indicatorColor;
                ctx.shadowBlur = 15;
            }

            draw() {
                this.drawStaminaBar(ctx);
                this.drawBoostIndicator(ctx);

                ctx.fillStyle = this.color;
                
                // Apply dash glow if dashing
                if (this.isDashing) {
                    ctx.shadowColor = '#f59e0b'; 
                    ctx.shadowBlur = 20;
                } else if (this.boostType === 0) {
                    // Reset shadow if no boost/dash
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                }

                ctx.beginPath();
                // Body (Rounded Rectangle)
                ctx.roundRect(this.x - this.width / 2, this.y, this.width, this.height, 5);
                ctx.fill();

                // Reset shadow before drawing features that shouldn't glow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;

                // Eyes (Small circles for simple face)
                ctx.fillStyle = '#1f2937';
                ctx.beginPath();
                ctx.arc(this.x - 10, this.y + 15, 3, 0, Math.PI * 2);
                ctx.arc(this.x + 10, this.y + 15, 3, 0, Math.PI * 2);
                ctx.fill();
            }

            update() {
                // ... (Existing update logic for physics, stamina, boost)
                // --- 1. Cooldown and State Management ---
                if (this.dashCooldown > 0) {
                    this.dashCooldown--;
                }
                // ‚≠ê CHANGE: Dash only lasts for 1 frame of impulse
                if (this.isDashing) {
                    this.isDashing = false; 
                }

                // --- 2. Stamina Management ---
                const isGrounded = this.y >= Court.floorY - this.height;
                if (isGrounded) {
                    this.stamina = Math.min(this.maxStamina, this.stamina + REGEN_RATE_GROUNDED);
                } else {
                    this.stamina = Math.min(this.maxStamina, this.stamina + REGEN_RATE_AIR);
                }

                // --- 3. Boost Timer ---
                if (this.boostType !== 0) {
                    this.boostTimer--;
                    if (this.boostTimer <= 0) {
                        this.boostType = 0;
                        this.boostTimer = 0;
                    }
                }

                // --- 4. Physics & Movement ---
                // Apply Gravity
                if (this.y < Court.floorY - this.height) {
                    this.dy += GRAVITY;
                    this.isJumping = true;
                } else {
                    this.y = Court.floorY - this.height;
                    this.dy = 0;
                    this.isJumping = false;
                    this.dashCooldown = 0; 
                }

                this.y += this.dy;

                // Horizontal movement
                this.x += this.dx;
                // ‚≠ê NEW FEATURE: Apply air resistance to horizontal movement if not dashing
                if (!this.isDashing && !isGrounded) {
                    this.dx *= 0.98;
                }
                
                // Restrict movement to own side
                const side = this.controls.side;
                if (this.x < Court.playerArea[side].minX + this.width / 2) {
                    this.x = Court.playerArea[side].minX + this.width / 2;
                }
                if (this.x > Court.playerArea[side].maxX - this.width / 2) {
                    this.x = Court.playerArea[side].maxX - this.width / 2;
                }
            }

            jump() {
                // ... (Existing jump logic)
                if (!this.isJumping && this.stamina >= JUMP_COST) {
                    this.stamina -= JUMP_COST;

                    let jumpPower = BASE_JUMP_POWER;
                    
                    // Apply boost power factor
                    if (this.boostType !== 0) {
                        jumpPower *= BOOST_JUMP_FACTOR;
                    }

                    this.dy = -jumpPower;
                    this.isJumping = true;
                    return true; // Return true on successful jump
                }
                return false; // Return false if jump failed
            }
            
            dash() {
                // ... (Existing dash logic)
                if (this.isJumping && this.stamina >= DASH_COST && this.dashCooldown === 0) {
                    this.stamina -= DASH_COST;
                    this.dashCooldown = DASH_COOLDOWN_FRAMES;
                    this.isDashing = true;
                    
                    let dashDir = 0;
                    if (this.dx > 0) dashDir = 1;
                    else if (this.dx < 0) dashDir = -1;
                    else dashDir = (this.controls.side === 'p1') ? 1 : -1; 
                    
                    this.dx = DASH_FORCE_H * dashDir;
                    this.dy = DASH_FORCE_V;
                    
                    if (audioReady) {
                        dashSynth.triggerAttackRelease('16n');
                    }
                }
            }
            
            // Method to apply a specific boost
            applyBoost(type) {
                this.boostType = type;
                this.boostTimer = BOOST_TIME;
            }
        }

        class Ball {
            constructor(x, y, radius) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.dx = 0;
                this.dy = 0;
                this.color = '#facc15';
                this.bounceFactor = 0.8;
                this.maxSpeed = 15;
                this.rotation = 0;
                this.rotationSpeed = 0; 
                this.trail = [];
                this.trailLength = 15;
            }
            
            // ‚≠ê NEW FEATURE: Ball Shadow Logic
            drawShadow() {
                const shadowEl = document.getElementById('ball-shadow');
                if (!shadowEl) return;

                const distanceToFloor = Court.floorY - (this.y + this.radius);
                const maxDistance = Court.floorY; 
                
                // Calculate opacity and size based on height
                let opacity = 0;
                let size = this.radius * 2; 

                if (distanceToFloor > 0) {
                    opacity = Math.min(0.7, 1 - (distanceToFloor / maxDistance));
                    size = this.radius * 2 * opacity * 1.5; 
                }

                // Position the shadow
                const containerRect = canvasContainerEl.getBoundingClientRect();
                const canvasRect = canvas.getBoundingClientRect();
                
                // Transform canvas coords to viewport/container coords (assuming no scaling yet)
                const shadowX = this.x + canvasRect.left - containerRect.left - size / 2;
                const shadowY = Court.floorY - this.radius + canvasRect.top - containerRect.top - size / 4; 

                shadowEl.style.left = `${shadowX}px`;
                shadowEl.style.top = `${shadowY}px`;
                shadowEl.style.width = `${size}px`;
                shadowEl.style.height = `${size * 0.5}px`; // Squashed for better look
                shadowEl.style.opacity = opacity;
            }
            // (The actual shadow DOM element will be created in the main init function)

            drawTrail() {
                // ... (Existing trail drawing)
                for (let i = 0; i < this.trail.length; i++) {
                    const { x, y } = this.trail[i];
                    const alpha = 1 - (i / this.trail.length); 
                    const radius = this.radius * (0.8 - i * 0.05); 

                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.5})`;
                    ctx.beginPath();
                    ctx.arc(x, y, radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            draw() {
                // Apply spike flash visual effect
                if (spikeFlashTimer > 0) {
                    ctx.fillStyle = 'rgba(255, 255, 255, ' + (spikeFlashTimer / 10) + ')';
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius * 2, 0, Math.PI * 2);
                    ctx.fill();
                    spikeFlashTimer--;
                }

                // Update visual rotation
                this.rotation += this.rotationSpeed * 0.1;

                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);

                // Draw Ball Body
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius, 0, Math.PI * 2);
                ctx.fill();

                // Simple lines to make it look like a volleyball (rotated)
                ctx.strokeStyle = '#fef3c7';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(-this.radius, 0);
                ctx.lineTo(this.radius, 0);
                ctx.moveTo(0, -this.radius);
                ctx.lineTo(0, this.radius);
                ctx.stroke();

                ctx.restore();
            }

            update() {
                if (!ballInPlay) {
                    this.trail = [];
                    this.rotationSpeed = 0;
                    return; 
                }

                this.trail.unshift({ x: this.x, y: this.y });
                if (this.trail.length > this.trailLength) {
                    this.trail.pop();
                }

                // ‚≠ê NEW FEATURE: Smoother Wind Implementation
                // Apply wind
                this.dx += windForce; 
                
                // Apply Magnus effect (Spin-induced lift)
                const lift = this.rotationSpeed * this.dx * MAGNUS_FACTOR;
                this.dy -= lift;

                this.dy += GRAVITY;

                this.rotationSpeed *= (1 - SPIN_AIR_DRAG);

                this.x += this.dx;
                this.y += this.dy;

                this.dx = Math.min(Math.max(this.dx, -this.maxSpeed), this.maxSpeed);
                this.dy = Math.min(Math.max(this.dy, -this.maxSpeed), this.maxSpeed);

                // Wall bounds (left and right)
                if (this.x - this.radius < 0) {
                    this.x = this.radius;
                    this.dx *= -this.bounceFactor;
                    this.rotationSpeed *= -0.8;
                    makeHitSound(0.5);
                }
                if (this.x + this.radius > Court.width) {
                    this.x = Court.width - this.radius;
                    this.dx *= -this.bounceFactor;
                    this.rotationSpeed *= -0.8;
                    makeHitSound(0.5);
                }
                
                // Ceiling bounds
                if (this.y - this.radius < 0) {
                    this.y = this.radius;
                    this.dy *= -this.bounceFactor * 0.5; // Less bounce off the ceiling
                    this.dx *= 0.95; // Slight friction
                    this.rotationSpeed *= -0.8;
                    makeHitSound(0.7);
                }

                // Floor check (out of bounds logic is separate in checkScore)
                if (this.y + this.radius > Court.floorY) {
                    this.y = Court.floorY - this.radius;
                    this.dy *= -this.bounceFactor; 
                    this.rotationSpeed *= -0.8;
                    
                    // Stop horizontal movement on low-speed bounce
                    if (Math.abs(this.dy) < 1) {
                        this.dy = 0;
                        this.dx *= 0.8; // Ground friction
                    }
                    
                    checkScore();
                }
            }
            
            // ‚≠ê NEW: Method to launch the ball for serving
            launch(player, forceX, forceY, spin) {
                this.x = player.x;
                this.y = player.y - this.radius * 2;
                this.dx = forceX;
                this.dy = forceY;
                this.rotationSpeed = spin;
                ballInPlay = true;
                player.isServing = false;
                lastPlayerHit = player; // Player who served is the last to touch
                
                // Set initial touches for the serving player
                if (player === p1) p1Touches = 1;
                else p2Touches = 1;
                
                statusMessageEl.textContent = "Ball in Play!";
            }
        }

        class PowerUp {
            constructor(x, y, radius, type) {
                this.x = x;
                this.y = y;
                this.radius = radius;
                this.type = type; // e.g., 'superJump'
                this.color = '#3b82f6'; // Blue star color
                this.dy = 0.5 * (Math.random() > 0.5 ? 1 : -1); // Subtle floating
                this.initialY = y;
                this.maxOffset = 5;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.fillStyle = this.color;
                
                // Draw a simple star shape
                ctx.beginPath();
                for (let i = 0; i < 5; i++) {
                    ctx.lineTo(Math.cos((18 + i * 72) * Math.PI / 180) * this.radius, 
                               Math.sin((18 + i * 72) * Math.PI / 180) * this.radius);
                    ctx.lineTo(Math.cos((54 + i * 72) * Math.PI / 180) * this.radius * 0.5, 
                               Math.sin((54 + i * 72) * Math.PI / 180) * this.radius * 0.5);
                }
                ctx.closePath();
                ctx.fill();
                
                // Subtle glowing effect
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 10;
                
                ctx.restore();
                
                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
            }

            update() {
                // Subtle floating animation
                this.y = this.initialY + Math.sin(Date.now() * 0.005) * this.maxOffset;
            }
        }

        // Initialize Game Objects
        const p1 = new Player(CANVAS_WIDTH * 0.25, '#facc15', { side: 'p1', jump: 'ArrowUp', left: 'ArrowLeft', right: 'ArrowRight', dash: 'e' });
        const p2 = new Player(CANVAS_WIDTH * 0.75, '#f87171', { side: 'p2' }); // P2 is AI controlled
        const ball = new Ball(CANVAS_WIDTH / 2, Court.floorY - 100, 10);

        // Input Handling
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            
            // Initial jump/serve trigger
            if (!ballInPlay && serveReady && e.key === ' ') { // SPACE to serve for P1
                if (lastServeSide === 'p1') {
                    p1.isServing = true;
                    // Auto-position ball for serve
                    ball.x = p1.x;
                    ball.y = p1.y - ball.radius * 2;
                    statusMessageEl.textContent = "Jump and hit with ‚Üë to serve!";
                }
            } else if (e.key === p1.controls.jump) {
                // Check for P1 jump/hit
                if (p1.isServing && ball.y > p1.y - p1.height * 0.5) { 
                    // Serve hit - simulate a hit after jump
                    handlePlayerHit(p1, ball);
                } else {
                    p1.jump();
                }
            } else if (e.key === p1.controls.dash) {
                p1.dash();
            } else if (e.key === 'p' || e.key === 'P') {
                togglePause();
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });
        
        // Mute/Restart Button Handlers
        restartButtonEl.addEventListener('click', () => {
            resetGame();
        });
        muteButtonEl.addEventListener('click', toggleMute);


        // --- Drawing Functions ---

        function drawCourt() {
            // Court Lines
            ctx.fillStyle = LINE_COLOR;
            // Floor line
            ctx.fillRect(0, Court.floorY, Court.width, 5); 
            // Center line
            ctx.fillRect(Court.netX - 2, Court.netY, 4, Court.floorY - Court.netY + 5); 
            
            // Net
            ctx.fillStyle = NET_COLOR;
            ctx.fillRect(Court.netX - 1, Court.netY, 2, Court.floorY - Court.netY + 5); 
        }

        function drawStatus() {
            if (winningPlayer) {
                ctx.fillStyle = winningPlayer === p1 ? p1.color : p2.color;
                ctx.font = 'bold 48px Chakra Petch';
                ctx.textAlign = 'center';
                const winText = winningPlayer === p1 ? 'PLAYER 1 WINS!' : 'COMPUTER WINS!';
                ctx.fillText(winText, Court.width / 2, Court.height / 2 - 20);
                
                ctx.font = 'bold 24px Chakra Petch';
                ctx.fillStyle = 'white';
                ctx.fillText('Press RESTART to play again', Court.width / 2, Court.height / 2 + 30);
                
            } else if (serveReady) {
                // If it's P2's turn, show AI serving
                if (lastServeSide === 'p2') {
                    statusMessageEl.textContent = "Computer is serving...";
                }
            }
        }
        
        function updateTimer() {
            if (!gameRunning || isPaused) return;

            gameTimeRemaining--;
            
            const minutes = Math.floor(gameTimeRemaining / 60);
            const seconds = gameTimeRemaining % 60;
            
            gameTimerEl.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

            if (gameTimeRemaining <= 0) {
                endGameByTimer();
            }
        }

        // --- Game Logic Functions ---

        function updateWind() {
            if (windTimer > 0) {
                windTimer--;
            } else {
                // New wind phase
                windTargetForce = (Math.random() - 0.5) * MAX_WIND_FORCE * 2;
                windTimer = WIND_DURATION_MIN + Math.random() * (WIND_DURATION_MAX - WIND_DURATION_MIN);
            }

            // Smoothly transition the current wind force to the target
            windForce += (windTargetForce - windForce) * windTransitionRate * (AI_SETTINGS.level / 5);

            // Update wind indicator
            windIndicatorEl.classList.remove('hidden');
            let windDir = '';
            let icon = 'üí®';
            
            if (Math.abs(windForce) < MAX_WIND_FORCE * 0.1) {
                windStrengthEl.textContent = 'Calm';
                windIconEl.textContent = '‚òÅÔ∏è';
            } else if (windForce > 0) {
                windStrengthEl.textContent = 'Left Wind';
                windIconEl.textContent = '‚¨ÖÔ∏è';
            } else {
                windStrengthEl.textContent = 'Right Wind';
                windIconEl.textContent = '‚û°Ô∏è';
            }
        }
        
        function createPowerUp() {
            if (powerUp) return; // Only one power-up at a time

            const side = Math.random() > 0.5 ? 'p1' : 'p2';
            const area = Court.playerArea[side];
            const x = area.minX + 50 + Math.random() * (area.maxX - area.minX - 100);
            const y = Court.netY + 50 + Math.random() * (Court.floorY - Court.netY - 100);
            
            powerUp = new PowerUp(x, y, 15, 'superJump');
            powerUpRespawnTimer = 0; // Reset timer
        }

        function checkNetCollision() {
            const netX = Court.netX;
            const netY = Court.netY;
            const netThickness = 4;

            // Check if ball is near the net's X position
            if (ball.x + ball.radius > netX - netThickness / 2 && ball.x - ball.radius < netX + netThickness / 2) {
                // Check if ball is below the top of the net
                if (ball.y + ball.radius > netY) {
                    
                    const newBounceFactor = 0.5; // Net absorbs energy
                    
                    // Horizontal collision (Bouncing off the net pole area or mesh)
                    if (ball.x < netX) {
                        // Hit from P1 side
                        ball.x = netX - netThickness / 2 - ball.radius;
                        ball.dx *= -newBounceFactor;
                    } else {
                        // Hit from P2 side
                        ball.x = netX + netThickness / 2 + ball.radius;
                        ball.dx *= -newBounceFactor;
                    }
                    
                    ball.rotationSpeed *= -0.5; // Lose spin
                    makeHitSound(0.3); // Muted sound for net hit
                }
            }
        }

        function isPlayerBallCollision(player, ball) {
            const dx = ball.x - Math.max(player.x - player.width / 2, Math.min(ball.x, player.x + player.width / 2));
            const dy = ball.y - Math.max(player.y, Math.min(ball.y, player.y + player.height));
            return (dx * dx + dy * dy) < (ball.radius * ball.radius);
        }

        function handlePlayerHit(player, ball) {
            
            // 1. Determine direction and speed
            const dx = ball.x - player.x;
            const dy = ball.y - player.y;
            const distance = Math.sqrt(dx * dx + dy * dy);

            // Angle of hit for more realistic reflection
            const normalX = dx / distance;
            const normalY = dy / distance;

            // Base speed increase
            let hitSpeedFactor = 1.3;
            if (player.boostType !== 0) {
                hitSpeedFactor = 2.0; // Higher boost for power-up/spike
            }
            
            // Calculate new velocity based on player movement and hit speed
            let newDx = (ball.dx * 0.5 + player.dx * 0.8) * hitSpeedFactor;
            let newDy = (ball.dy * 0.5 + player.dy * 0.8) * hitSpeedFactor * 0.8; // Vertical is slightly dampened for control

            // Apply a strong vertical component upwards on hit
            newDy = Math.min(newDy, -10); 
            
            // 2. Set new ball velocity and spin
            ball.dx = newDx;
            ball.dy = newDy;
            
            // Apply spin based on player horizontal movement
            // Positive rotationSpeed is clockwise, which causes the ball to curve to the left if moving right (Magnus)
            ball.rotationSpeed = player.dx * 0.2; 

            // Prevent repeated hits in the same frame
            ball.x += ball.dx; 
            ball.y += ball.dy;

            // 3. Update game state
            if (player.controls.side === 'p1') {
                p1Touches++;
                p2Touches = 0; // Reset opponent's touches
            } else {
                p2Touches++;
                p1Touches = 0;
            }

            // Check for illegal touch (over the limit)
            if ((player.controls.side === 'p1' && p1Touches > MAX_TOUCHES) || 
                (player.controls.side === 'p2' && p2Touches > MAX_TOUCHES)) {
                // Illegal touch counts as an immediate point for the opponent
                givePoint(player.controls.side === 'p1' ? p2 : p1, "TOO MANY TOUCHES! Point for Opponent.");
                return;
            }

            lastPlayerHit = player;
            serveReady = false; 
            
            // 4. Visual/Audio effects
            const isSpike = (player.y > Court.netY) && (Math.abs(ball.dx) > 10 || player.boostType > 0);
            
            if (isSpike) {
                // Spike effect: Screen shake and louder sound
                spikeFlashTimer = 10;
                startScreenShake(5, 5); 
                if (audioReady) spikeSynth.triggerAttackRelease('8n', Tone.now(), 0.9);
                player.applyBoost(1); // Apply Spike Boost
            } else {
                if (audioReady) hitSynth.triggerAttackRelease("C4", "8n");
            }
        }

        function checkPlayerCollisions() {
            // Player 1 vs Ball
            if (ballInPlay && isPlayerBallCollision(p1, ball)) {
                if (p1.isServing) {
                    // Ball is already in motion after jump, this is the hit/serve action
                    handlePlayerHit(p1, ball);
                } else if (!p1.isServing) {
                    handlePlayerHit(p1, ball);
                }
            }
            
            // Player 2 vs Ball (AI)
            if (ballInPlay && isPlayerBallCollision(p2, ball)) {
                if (p2.isServing) {
                    // Ball is already in motion after jump, this is the hit/serve action
                    handlePlayerHit(p2, ball);
                } else if (!p2.isServing) {
                    handlePlayerHit(p2, ball);
                }
            }
        }

        function checkPowerUpCollision() {
            if (!powerUp) return;

            const players = [p1, p2];

            for (const player of players) {
                const dx = powerUp.x - player.x;
                const dy = powerUp.y - (player.y + player.height / 2); // Center of player body
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < powerUp.radius + player.width / 2) {
                    // Collision detected!
                    
                    player.applyBoost(2); // Apply Super Jump Boost
                    powerUp = null; // Remove power-up
                    powerUpRespawnTimer = POWERUP_RESPAWN_MIN + Math.random() * (POWERUP_RESPAWN_MAX - POWERUP_RESPAWN_MIN);

                    if (audioReady) {
                        powerupSynth.triggerAttackRelease("C5", "8n");
                        powerupSynth.triggerAttackRelease("G5", "8n", "+0.05");
                    }
                    startScreenShake(3, 2);
                    break; 
                }
            }
        }

        function checkScore() {
            if (!ballInPlay) return;

            let pointScored = false;
            let scorer = null;
            let message = "";

            // Ball hit the floor?
            if (ball.y + ball.radius >= Court.floorY) {
                pointScored = true;
                
                // If ball landed on P1 side (x < netX)
                if (ball.x < Court.netX) {
                    scorer = p2;
                    message = "Point for Computer (P2)!";
                } 
                // If ball landed on P2 side (x > netX)
                else {
                    scorer = p1;
                    message = "Point for Player 1 (P1)!";
                }
                
                // Ball fell on the floor, so reset all movement
                ball.dx = 0;
                ball.dy = 0;
                ballInPlay = false;

            } else if (ball.x + ball.radius < 0 || ball.x - ball.radius > Court.width) {
                // Out of bounds (unlikely with current wall physics, but good safeguard)
                pointScored = true;
                scorer = lastPlayerHit === p1 ? p2 : p1;
                message = "Out of Bounds! Point for Opponent.";
            }

            if (pointScored && scorer) {
                givePoint(scorer, message);
            }
        }

        function givePoint(scorer, message) {
            scorer.score++;
            statusMessageEl.textContent = message;
            
            // Set next server
            lastServeSide = scorer.controls.side; 
            
            // Reset state
            p1Touches = 0;
            p2Touches = 0;
            ballInPlay = false;
            serveReady = true;
            
            p1.resetPosition();
            p2.resetPosition();
            
            // Position ball for new serve
            if (lastServeSide === 'p1') {
                ball.x = p1.x;
                ball.y = p1.y - ball.radius * 2;
                statusMessageEl.textContent = "P1 to serve: Press SPACE";
            } else {
                ball.x = p2.x;
                ball.y = p2.y - ball.radius * 2;
                // AI serve logic is in the update loop
                statusMessageEl.textContent = "Computer is serving...";
            }
            ball.dx = 0;
            ball.dy = 0;
            
            updateScores();

            // Check for game over
            if (isScoreLimitMode && scorer.score >= MAX_SCORE) {
                winningPlayer = scorer;
                endGame();
            }
            
            if (audioReady) {
                scoreSynth.triggerAttackRelease("C5", "4n"); 
            }
        }
        
        function updateScores() {
            scoreP1El.textContent = `P1 (Arrows): ${p1.score}`;
            scoreP2El.textContent = `Computer: ${p2.score}`;
        }
        
        function endGameByTimer() {
            if (p1.score > p2.score) {
                winningPlayer = p1;
            } else if (p2.score > p1.score) {
                winningPlayer = p2;
            } else {
                winningPlayer = 'Tie'; // A string for tie state
            }
            
            // Overwrite the status message for the timer end
            if (winningPlayer === 'Tie') {
                statusMessageEl.textContent = "TIME UP! It's a TIE!";
            } else if (winningPlayer === p1) {
                statusMessageEl.textContent = `TIME UP! P1 WINS ${p1.score}-${p2.score}!`;
            } else {
                statusMessageEl.textContent = `TIME UP! COMPUTER WINS ${p2.score}-${p1.score}!`;
            }
            
            endGame();
        }

        function endGame() {
            gameRunning = false;
            ballInPlay = false;
            
            // Ensure status message is final
            drawStatus(); 
            
            // Show restart button
            restartButtonEl.classList.remove('hidden');
            
            if (audioReady && winningPlayer !== 'Tie') {
                gameEndSynth.triggerAttackRelease(winningPlayer === p1 ? "C4" : "C#4", "2n");
            }
        }

        function resetGame() {
            p1.score = 0;
            p2.score = 0;
            gameTimeRemaining = GAME_TIMER_SECONDS;
            winningPlayer = null;
            gameRunning = true;
            restartButtonEl.classList.add('hidden');
            
            // Randomly pick who serves first
            lastServeSide = Math.random() < 0.5 ? 'p1' : 'p2'; 
            
            p1.resetPosition();
            p2.resetPosition();
            
            if (lastServeSide === 'p1') {
                ball.x = p1.x;
                statusMessageEl.textContent = "Press SPACE to serve";
            } else {
                ball.x = p2.x;
                statusMessageEl.textContent = "Computer is serving...";
            }
            
            ball.y = Court.floorY - ball.radius * 2;
            ball.dx = 0;
            ball.dy = 0;
            ballInPlay = false;
            serveReady = true;
            
            updateScores();
            
            // Reset power-up and wind
            powerUp = null;
            powerUpRespawnTimer = POWERUP_RESPAWN_MIN; // Start the clock for first powerup
            windForce = 0;
            windTargetForce = 0;
        }

        // --- Utility Functions ---
        
        function makeHitSound(velocityFactor) {
            if (!audioReady || isMuted) return;

            // Pitch and volume based on speed
            const speed = Math.min(1, Math.sqrt(ball.dx * ball.dx + ball.dy * ball.dy) / ball.maxSpeed) * velocityFactor;
            const note = speed > 0.5 ? "A4" : "F4";
            const volume = -10 + speed * 10; 
            
            hitSynth.set({ volume: volume });
            hitSynth.triggerAttackRelease(note, "16n");
        }

        function startScreenShake(duration, intensity) {
            screenShakeDuration = duration; // frames
            screenShakeIntensity = intensity; // pixels
        }

        function applyScreenShake() {
            if (screenShakeDuration > 0) {
                screenShakeDuration--;
                const xOffset = Math.random() * screenShakeIntensity * 2 - screenShakeIntensity;
                const yOffset = Math.random() * screenShakeIntensity * 2 - screenShakeIntensity;
                
                canvasContainerEl.style.transform = `translate(${xOffset}px, ${yOffset}px)`;
            } else {
                canvasContainerEl.style.transform = 'translate(0, 0)';
            }
        }

        function togglePause() {
            if (winningPlayer) return; // Cannot pause game over

            isPaused = !isPaused;

            if (isPaused) {
                pauseOverlayEl.style.display = 'flex';
                // Stop the game loop implicitly by skipping the update call
            } else {
                pauseOverlayEl.style.display = 'none';
                // Resume game loop
                requestAnimationFrame(gameLoop);
            }
        }
        
        // --- AI Logic (Player 2) ---

        const AI = {
            
            // ‚≠ê NEW FEATURE: AI Dash Cooldown Tracker
            dashCounter: 0,
            
            controlP2: function(p2, ball) {
                // If game is not running or ball is not in play, only focus on serving
                if (!gameRunning) return;
                
                // --- 1. Serving Logic (FIX: Computer not launching the ball) ---
                if (serveReady && lastServeSide === 'p2') {
                    // 1. Move to a good serving position (close to the center line of its side)
                    const targetX = Court.netX + 50; 
                    if (p2.x < targetX) {
                        p2.dx = AI_SETTINGS.getSpeed();
                    } else if (p2.x > targetX) {
                        p2.dx = -AI_SETTINGS.getSpeed();
                    } else {
                        p2.dx = 0;
                    }
                    
                    // 2. Once in position, trigger the jump/hit action (serve)
                    if (Math.abs(p2.x - targetX) < p2.width / 4) {
                        p2.isServing = true; // Set serving state
                        ball.x = p2.x; // Position ball for serve
                        ball.y = p2.y - ball.radius * 2;
                        
                        // Wait for a slight random delay (to simulate reaction time)
                        if (Math.random() < (AI_SETTINGS.level / 100)) { // Speed of reaction increases with level
                            // The AI needs to "jump" (hit) to launch the ball.
                            // The jump function is overloaded to perform the serve hit if isServing is true AND ball is near.
                            // For AI, we just call jump(), it'll position and hit in the same frame due to ball positioning.
                            if (p2.jump()) {
                                // Successful jump means the ball is hit due to the main logic flow checking for a hit immediately after jump
                                // We can directly launch the ball here for a more robust serve if the above jump/hit logic is hard to trigger:
                                
                                // FORCE LAUNCH:
                                const forceX = -5 + (AI_SETTINGS.level - 5) * -0.5; // Towards P1, more aggressive with higher level
                                const forceY = -8; 
                                const spin = 10 * Math.random() * (AI_SETTINGS.level / 10); // Random spin
                                ball.launch(p2, forceX, forceY, spin); 
                                p2.isServing = false; // Reset state after launch
                            }
                        }
                    }
                    return;
                }
                
                // If not serving, proceed with defensive/offensive logic
                p2.isServing = false;
                
                // --- 2. Follow Ball Logic ---
                if (ballInPlay) {
                    const playerCenterY = p2.y + p2.height / 2;
                    const ballGroundX = ball.x + (Court.floorY - ball.y) * (ball.dx / ball.dy); // Extrapolate where the ball will land
                    const ballCeilingY = ball.y - ball.radius;

                    let targetX;

                    // If ball is on P2 side and is high (offensive position)
                    if (ball.x > Court.netX && ballCeilingY < Court.netY) {
                        targetX = ball.x; // Move directly under the ball for a spike/block
                    } 
                    // If ball is on P1 side (wait for it near the net)
                    else if (ball.x < Court.netX) {
                        targetX = Court.netX + 50; // Wait near the net
                    } 
                    // If ball is on P2 side and low (defensive position)
                    else {
                        targetX = ballGroundX; // Go to where the ball is expected to land
                        // Clamp targetX to P2's side
                        targetX = Math.min(Court.playerArea.p2.maxX - p2.width / 2, Math.max(Court.playerArea.p2.minX + p2.width / 2, targetX));
                    }

                    // Horizontal Movement
                    const speed = AI_SETTINGS.getSpeed();
                    if (p2.x < targetX - 5) {
                        p2.dx = speed;
                    } else if (p2.x > targetX + 5) {
                        p2.dx = -speed;
                    } else {
                        p2.dx = 0;
                    }

                    // --- 3. Jump/Hit Logic ---
                    const distanceToBall = Math.sqrt(Math.pow(p2.x - ball.x, 2) + Math.pow(playerCenterY - ball.y, 2));
                    const jumpThreshold = AI_SETTINGS.getJumpRange(); // Dynamic jump range

                    if (ball.x > Court.netX && distanceToBall < jumpThreshold) {
                        // Prediction: If ball is falling and close enough
                        if (ball.dy > 0 && ball.y + ball.radius < Court.floorY) {
                            p2.jump();
                        }
                        // Prediction: If ball is high and player is already under it for block/spike
                        else if (ball.y < Court.netY && Math.abs(p2.x - ball.x) < p2.width) {
                            p2.jump();
                        }
                    }
                    
                    // --- 4. Dash Logic (Strategic Dash) ---
                    this.dashCounter++;
                    if (this.dashCounter > DASH_COOLDOWN_FRAMES) {
                        // Dash if jump wasn't enough AND the ball is in a hittable position above the net
                        const hitPosition = ball.y - ball.radius < Court.netY;
                        const hasStamina = p2.stamina >= DASH_COST;
                        
                        if (p2.isJumping && hasStamina && hitPosition && Math.random() < AI_SETTINGS.getDashChance()) {
                            p2.dash();
                            this.dashCounter = 0; // Reset counter for cooldown
                        }
                    }
                    
                } else {
                    // No ball in play, center the player
                    const center = CANVAS_WIDTH * 0.75;
                    const speed = AI_SETTINGS.getSpeed() * 0.5;
                    if (p2.x < center - 5) p2.dx = speed;
                    else if (p2.x > center + 5) p2.dx = -speed;
                    else p2.dx = 0;
                }
            }
        };

        // --- Main Game Loop ---
        let lastTime = 0;
        const fps = 60;
        const interval = 1000 / fps;
        let elapsed = 0;
        
        let timerCounter = 0;

        function gameLoop(timestamp) {
            if (isPaused) return; // Exit early if paused

            if (timestamp < lastTime + interval) {
                requestAnimationFrame(gameLoop);
                return;
            }
            elapsed = timestamp - lastTime;
            lastTime = timestamp - (elapsed % interval); // Adjust for frame drift

            ctx.clearRect(0, 0, Court.width, Court.height);

            if (gameRunning) {
                
                // Update timers and effects
                updateWind();
                applyScreenShake();
                
                // Power-up spawning
                if (!powerUp) {
                    powerUpRespawnTimer--;
                    if (powerUpRespawnTimer <= 0) {
                        createPowerUp();
                    }
                }
                if (powerUp) {
                    powerUp.update();
                }

                // Input & AI Control
                handleP1Input();
                AI.controlP2(p2, ball); 

                // Object Updates
                p1.update();
                p2.update();
                ball.update();
                
                if (ballInPlay) {
                    checkNetCollision();
                    checkPlayerCollisions();
                    checkPowerUpCollision();
                }
                
                // Drawing
                ctx.fillStyle = COURT_COLOR;
                ctx.fillRect(0, 0, Court.width, Court.height); 

                drawCourt();
                
                if (powerUp) {
                    powerUp.draw();
                }
                
                ball.drawTrail();
                ball.drawShadow(); 
                ball.draw();
                p1.draw();
                p2.draw();

                // Timer Update (every 60 frames for 1 second)
                timerCounter++;
                if (timerCounter >= 60) {
                    updateTimer();
                    timerCounter = 0;
                }
            }
            
            drawStatus();

            if (gameRunning) {
                requestAnimationFrame(gameLoop);
            }
        }

        // P1 Input Handling (called from gameLoop)
        function handleP1Input() {
            let speed = BASE_PLAYER_SPEED;
            let boostFactor = 1.0;
            
            if (p1.boostType === 1) boostFactor = BOOST_SPEED_FACTOR;
            else if (p1.boostType === 2) boostFactor = BOOST_SPEED_FACTOR * 1.2; 
            
            speed *= boostFactor;

            if (keys[p1.controls.left]) {
                p1.dx = -speed;
            } else if (keys[p1.controls.right]) {
                p1.dx = speed;
            } else {
                // Ground friction stop
                if (!p1.isJumping) {
                    p1.dx *= 0.8; 
                }
            }
        }
        
        // --- Initialization ---

        function init() {
            // Create ball shadow element for visual effect
            const shadowEl = document.createElement('div');
            shadowEl.id = 'ball-shadow';
            shadowEl.className = 'ball-shadow';
            canvasContainerEl.appendChild(shadowEl);
            
            // Set up audio on first interaction
            initAudio();
            
            // Initial difficulty setup
            const initialLevel = parseInt(difficultySliderEl.value);
            AI_SETTINGS.level = initialLevel;
            
            let labelText = '';
            let labelColor = 'text-yellow-300';
            if (initialLevel <= 3) { labelText = 'Easy'; labelColor = 'text-green-400'; }
            else if (initialLevel <= 7) { labelText = 'Medium'; labelColor = 'text-yellow-300'; }
            else { labelText = 'Hard'; labelColor = 'text-red-500'; }
            
            difficultyLabelEl.textContent = `${labelText} (${initialLevel})`;
            difficultyLabelEl.className = `ml-3 w-20 font-bold text-left ${labelColor}`;
            
            resetGame();
            requestAnimationFrame(gameLoop);
        }

        init(); 
    </script>
</body>
</html>